{"ast":null,"code":"'use strict';\n\nvar ASN1 = module.exports;\n\nvar Enc = require('@root/encoding/hex'); //\n// Packer\n//\n// Almost every ASN.1 type that's important for CSR\n// can be represented generically with only a few rules.\n\n\nfunction Any()\n/*type, hexstrings...*/\n{\n  var args = Array.prototype.slice.call(arguments);\n  var typ = args.shift();\n  var str = args.join('').replace(/\\s+/g, '').toLowerCase();\n  var len = str.length / 2;\n  var lenlen = 0;\n  var hex = typ;\n\n  if ('number' === typeof hex) {\n    hex = Enc.numToHex(hex);\n  } // We can't have an odd number of hex chars\n\n\n  if (len !== Math.round(len)) {\n    throw new Error('invalid hex');\n  } // The first byte of any ASN.1 sequence is the type (Sequence, Integer, etc)\n  // The second byte is either the size of the value, or the size of its size\n  // 1. If the second byte is < 0x80 (128) it is considered the size\n  // 2. If it is > 0x80 then it describes the number of bytes of the size\n  //    ex: 0x82 means the next 2 bytes describe the size of the value\n  // 3. The special case of exactly 0x80 is \"indefinite\" length (to end-of-file)\n\n\n  if (len > 127) {\n    lenlen += 1;\n\n    while (len > 255) {\n      lenlen += 1;\n      len = len >> 8;\n    }\n  }\n\n  if (lenlen) {\n    hex += Enc.numToHex(0x80 + lenlen);\n  }\n\n  return hex + Enc.numToHex(str.length / 2) + str;\n}\n\nASN1.Any = Any; // The Integer type has some special rules\n\nASN1.UInt = function UINT() {\n  var str = Array.prototype.slice.call(arguments).join('');\n  var first = parseInt(str.slice(0, 2), 16); // If the first byte is 0x80 or greater, the number is considered negative\n  // Therefore we add a '00' prefix if the 0x80 bit is set\n\n  if (0x80 & first) {\n    str = '00' + str;\n  }\n\n  return Any('02', str);\n}; // The Bit String type also has a special rule\n\n\nASN1.BitStr = function BITSTR() {\n  var str = Array.prototype.slice.call(arguments).join(''); // '00' is a mask of how many bits of the next byte to ignore\n\n  return Any('03', '00' + str);\n};\n\nASN1._toArray = function toArray(next, opts) {\n  var typ = opts.json ? Enc.numToHex(next.type) : next.type;\n  var val = next.value;\n\n  if (val) {\n    if ('string' !== typeof val && opts.json) {\n      val = Enc.bufToHex(val);\n    }\n\n    return [typ, val];\n  }\n\n  return [typ, next.children.map(function (child) {\n    return toArray(child, opts);\n  })];\n};\n\nASN1._pack = function (arr) {\n  var typ = arr[0];\n\n  if ('number' === typeof arr[0]) {\n    typ = Enc.numToHex(arr[0]);\n  }\n\n  var str = '';\n\n  if (Array.isArray(arr[1])) {\n    arr[1].forEach(function (a) {\n      str += ASN1._pack(a);\n    });\n  } else if ('string' === typeof arr[1]) {\n    str = arr[1];\n  } else if (arr[1].byteLength) {\n    str = Enc.bufToHex(arr[1]);\n  } else {\n    throw new Error('unexpected array');\n  }\n\n  if ('03' === typ) {\n    return ASN1.BitStr(str);\n  } else if ('02' === typ) {\n    return ASN1.UInt(str);\n  } else {\n    return Any(typ, str);\n  }\n}; // TODO should this return a buffer?\n\n\nASN1.pack = function (asn1, opts) {\n  if (!opts) {\n    opts = {};\n  }\n\n  if (!Array.isArray(asn1)) {\n    asn1 = ASN1._toArray(asn1, {\n      json: true\n    });\n  }\n\n  var result = ASN1._pack(asn1);\n\n  if (opts.json) {\n    return result;\n  }\n\n  return Enc.hexToBuf(result);\n};","map":{"version":3,"sources":["C:/Users/xuwen/Desktop/INFO340/project-2-xuwensi/node_modules/@root/asn1/packer.js"],"names":["ASN1","module","exports","Enc","require","Any","args","Array","prototype","slice","call","arguments","typ","shift","str","join","replace","toLowerCase","len","length","lenlen","hex","numToHex","Math","round","Error","UInt","UINT","first","parseInt","BitStr","BITSTR","_toArray","toArray","next","opts","json","type","val","value","bufToHex","children","map","child","_pack","arr","isArray","forEach","a","byteLength","pack","asn1","result","hexToBuf"],"mappings":"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","sourcesContent":["'use strict';\n\nvar ASN1 = module.exports;\nvar Enc = require('@root/encoding/hex');\n\n//\n// Packer\n//\n\n// Almost every ASN.1 type that's important for CSR\n// can be represented generically with only a few rules.\nfunction Any(/*type, hexstrings...*/) {\n\tvar args = Array.prototype.slice.call(arguments);\n\tvar typ = args.shift();\n\tvar str = args\n\t\t.join('')\n\t\t.replace(/\\s+/g, '')\n\t\t.toLowerCase();\n\tvar len = str.length / 2;\n\tvar lenlen = 0;\n\tvar hex = typ;\n\tif ('number' === typeof hex) {\n\t\thex = Enc.numToHex(hex);\n\t}\n\n\t// We can't have an odd number of hex chars\n\tif (len !== Math.round(len)) {\n\t\tthrow new Error('invalid hex');\n\t}\n\n\t// The first byte of any ASN.1 sequence is the type (Sequence, Integer, etc)\n\t// The second byte is either the size of the value, or the size of its size\n\n\t// 1. If the second byte is < 0x80 (128) it is considered the size\n\t// 2. If it is > 0x80 then it describes the number of bytes of the size\n\t//    ex: 0x82 means the next 2 bytes describe the size of the value\n\t// 3. The special case of exactly 0x80 is \"indefinite\" length (to end-of-file)\n\n\tif (len > 127) {\n\t\tlenlen += 1;\n\t\twhile (len > 255) {\n\t\t\tlenlen += 1;\n\t\t\tlen = len >> 8;\n\t\t}\n\t}\n\n\tif (lenlen) {\n\t\thex += Enc.numToHex(0x80 + lenlen);\n\t}\n\treturn hex + Enc.numToHex(str.length / 2) + str;\n}\nASN1.Any = Any;\n\n// The Integer type has some special rules\nASN1.UInt = function UINT() {\n\tvar str = Array.prototype.slice.call(arguments).join('');\n\tvar first = parseInt(str.slice(0, 2), 16);\n\n\t// If the first byte is 0x80 or greater, the number is considered negative\n\t// Therefore we add a '00' prefix if the 0x80 bit is set\n\tif (0x80 & first) {\n\t\tstr = '00' + str;\n\t}\n\n\treturn Any('02', str);\n};\n\n// The Bit String type also has a special rule\nASN1.BitStr = function BITSTR() {\n\tvar str = Array.prototype.slice.call(arguments).join('');\n\t// '00' is a mask of how many bits of the next byte to ignore\n\treturn Any('03', '00' + str);\n};\n\nASN1._toArray = function toArray(next, opts) {\n\tvar typ = opts.json ? Enc.numToHex(next.type) : next.type;\n\tvar val = next.value;\n\tif (val) {\n\t\tif ('string' !== typeof val && opts.json) {\n\t\t\tval = Enc.bufToHex(val);\n\t\t}\n\t\treturn [typ, val];\n\t}\n\treturn [\n\t\ttyp,\n\t\tnext.children.map(function(child) {\n\t\t\treturn toArray(child, opts);\n\t\t})\n\t];\n};\n\nASN1._pack = function(arr) {\n\tvar typ = arr[0];\n\tif ('number' === typeof arr[0]) {\n\t\ttyp = Enc.numToHex(arr[0]);\n\t}\n\tvar str = '';\n\tif (Array.isArray(arr[1])) {\n\t\tarr[1].forEach(function(a) {\n\t\t\tstr += ASN1._pack(a);\n\t\t});\n\t} else if ('string' === typeof arr[1]) {\n\t\tstr = arr[1];\n\t} else if (arr[1].byteLength) {\n\t\tstr = Enc.bufToHex(arr[1]);\n\t} else {\n\t\tthrow new Error('unexpected array');\n\t}\n\tif ('03' === typ) {\n\t\treturn ASN1.BitStr(str);\n\t} else if ('02' === typ) {\n\t\treturn ASN1.UInt(str);\n\t} else {\n\t\treturn Any(typ, str);\n\t}\n};\n\n// TODO should this return a buffer?\nASN1.pack = function(asn1, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tif (!Array.isArray(asn1)) {\n\t\tasn1 = ASN1._toArray(asn1, { json: true });\n\t}\n\tvar result = ASN1._pack(asn1);\n\tif (opts.json) {\n\t\treturn result;\n\t}\n\treturn Enc.hexToBuf(result);\n};\n"]},"metadata":{},"sourceType":"script"}