{"ast":null,"code":"// Copyright 2018-present AJ ONeal. All rights reserved\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n'use strict';\n/*global Promise*/\n\nvar Enc = require('@root/encoding');\n\nvar ASN1 = require('@root/asn1/packer'); // DER, actually\n\n\nvar Asn1 = ASN1.Any;\nvar BitStr = ASN1.BitStr;\nvar UInt = ASN1.UInt;\n\nvar Asn1Parser = require('@root/asn1/parser');\n\nvar PEM = require('@root/pem');\n\nvar X509 = require('@root/x509'); // TODO @root/keypairs/sign\n\n\nvar Keypairs = require('@root/keypairs'); // TODO find a way that the prior node-ish way of `module.exports = function () {}` isn't broken\n\n\nvar CSR = module.exports; // { jwk, domains }\n\nCSR.csr = function (opts) {\n  // We're using a Promise here to be compatible with the browser version\n  // which will probably use the webcrypto API for some of the conversions\n  return CSR._prepare(opts).then(function (opts) {\n    return CSR.create(opts).then(function (bytes) {\n      return CSR._encode(opts, bytes);\n    });\n  });\n};\n\nCSR._prepare = function (opts) {\n  return Promise.resolve().then(function () {\n    opts = JSON.parse(JSON.stringify(opts)); // We do a bit of extra error checking for user convenience\n\n    if (!opts) {\n      throw new Error('You must pass options with key and domains to rsacsr');\n    }\n\n    if (!Array.isArray(opts.domains) || 0 === opts.domains.length) {\n      new Error('You must pass options.domains as a non-empty array');\n    } // I need to check that 例.中国 is a valid domain name\n\n\n    if (!opts.domains.every(function (d) {\n      // allow punycode? xn--\n      if ('string' === typeof d\n      /*&& /\\./.test(d) && !/--/.test(d)*/\n      ) {\n          return true;\n        }\n    })) {\n      throw new Error('You must pass options.domains as strings');\n    }\n\n    if (opts.jwk) {\n      return opts;\n    }\n\n    if (opts.key && opts.key.kty) {\n      opts.jwk = opts.key;\n      return opts;\n    }\n\n    if (!opts.pem && !opts.key) {\n      throw new Error('You must pass options.key as a JSON web key');\n    }\n\n    return Keypairs.import({\n      pem: opts.pem || opts.key\n    }).then(function (pair) {\n      opts.jwk = pair.private;\n      return opts;\n    });\n  });\n};\n\nCSR._encode = function (opts, bytes) {\n  if ('der' === (opts.encoding || '').toLowerCase()) {\n    return bytes;\n  }\n\n  return PEM.packBlock({\n    type: 'CERTIFICATE REQUEST',\n    bytes: bytes\n    /* { jwk: jwk, domains: opts.domains } */\n\n  });\n}; // { jwk, domains }\n\n\nCSR.create = function createCsr(opts) {\n  var hex = CSR.request({\n    jwk: opts.jwk,\n    domains: opts.domains,\n    encoding: 'hex'\n  });\n  return CSR._sign(opts.jwk, hex).then(function (csr) {\n    return Enc.hexToBuf(csr);\n  });\n}; //\n// EC / RSA\n//\n// { jwk, domains }\n\n\nCSR.request = function createCsrBody(opts) {\n  var asn1pub;\n\n  if (/^EC/i.test(opts.jwk.kty)) {\n    asn1pub = X509.packCsrEcPublicKey(opts.jwk);\n  } else {\n    asn1pub = X509.packCsrRsaPublicKey(opts.jwk);\n  }\n\n  var hex = X509.packCsr(asn1pub, opts.domains);\n\n  if ('hex' === opts.encoding) {\n    return hex;\n  } // der\n\n\n  return Enc.hexToBuf(hex);\n};\n\nCSR._sign = function csrEcSig(jwk, request) {\n  // Took some tips from https://gist.github.com/codermapuche/da4f96cdb6d5ff53b7ebc156ec46a10a\n  // TODO will have to convert web ECDSA signatures to PEM ECDSA signatures (but RSA should be the same)\n  // TODO have a consistent non-private way to sign\n  return Keypairs.sign({\n    jwk: jwk,\n    format: 'x509'\n  }, Enc.hexToBuf(request)).then(function (sig) {\n    return CSR._toDer({\n      request: request,\n      signature: sig,\n      kty: jwk.kty\n    });\n  });\n};\n\nCSR._toDer = function encode(opts) {\n  var sty;\n\n  if (/^EC/i.test(opts.kty)) {\n    // 1.2.840.10045.4.3.2 ecdsaWithSHA256 (ANSI X9.62 ECDSA algorithm with SHA256)\n    sty = Asn1('30', Asn1('06', '2a8648ce3d040302'));\n  } else {\n    // 1.2.840.113549.1.1.11 sha256WithRSAEncryption (PKCS #1)\n    sty = Asn1('30', Asn1('06', '2a864886f70d01010b'), Asn1('05'));\n  }\n\n  return Asn1('30', // The Full CSR Request Body\n  opts.request, // The Signature Type\n  sty, // The Signature\n  BitStr(Enc.bufToHex(opts.signature)));\n};\n\nX509.packCsr = function (asn1pubkey, domains) {\n  return Asn1('30', // Version (0)\n  UInt('00'), // 2.5.4.3 commonName (X.520 DN component)\n  Asn1('30', Asn1('31', Asn1('30', Asn1('06', '550403'), // TODO utf8 => punycode\n  Asn1('0c', Enc.strToHex(domains[0]))))), // Public Key (RSA or EC)\n  asn1pubkey, // Request Body\n  Asn1('a0', Asn1('30', // 1.2.840.113549.1.9.14 extensionRequest (PKCS #9 via CRMF)\n  Asn1('06', '2a864886f70d01090e'), Asn1('31', Asn1('30', Asn1('30', // 2.5.29.17 subjectAltName (X.509 extension)\n  Asn1('06', '551d11'), Asn1('04', Asn1('30', domains.map(function (d) {\n    // TODO utf8 => punycode\n    return Asn1('82', Enc.strToHex(d));\n  }).join('')))))))));\n}; // TODO finish this later\n// we want to parse the domains, the public key, and verify the signature\n\n\nCSR._info = function (der) {\n  // standard base64 PEM\n  if ('string' === typeof der && '-' === der[0]) {\n    der = PEM.parseBlock(der).bytes;\n  } // jose urlBase64 not-PEM\n\n\n  if ('string' === typeof der) {\n    der = Enc.base64ToBuf(der);\n  } // not supporting binary-encoded base64\n\n\n  var c = Asn1Parser.parse({\n    der: der,\n    verbose: true,\n    json: false\n  });\n  var kty; // A cert has 3 parts: cert, signature meta, signature\n\n  if (c.children.length !== 3) {\n    throw new Error(\"doesn't look like a certificate request: expected 3 parts of header\");\n  }\n\n  var sig = c.children[2];\n\n  if (sig.children.length) {\n    // ASN1/X509 EC\n    sig = sig.children[0];\n    sig = Asn1('30', UInt(Enc.bufToHex(sig.children[0].value)), UInt(Enc.bufToHex(sig.children[1].value)));\n    sig = Enc.hexToBuf(sig);\n    kty = 'EC';\n  } else {\n    // Raw RSA Sig\n    sig = sig.value;\n    kty = 'RSA';\n  } //c.children[1]; // signature type\n\n\n  var req = c.children[0];\n\n  if (4 !== req.children.length) {\n    throw new Error(\"doesn't look like a certificate request: expected 4 parts to request\");\n  } // 0 null\n  // 1 commonName / subject\n\n\n  var sub = Enc.bufToStr(req.children[1].children[0].children[0].children[1].value); // 3 public key (type, key)\n  //console.log('oid', Enc.bufToHex(req.children[2].children[0].children[0].value));\n\n  var pub; // TODO reuse ASN1 parser for these?\n\n  if ('EC' === kty) {\n    // throw away compression byte\n    pub = req.children[2].children[1].value.slice(1);\n    pub = {\n      kty: kty,\n      x: pub.slice(0, 32),\n      y: pub.slice(32)\n    };\n\n    while (0 === pub.x[0]) {\n      pub.x = pub.x.slice(1);\n    }\n\n    while (0 === pub.y[0]) {\n      pub.y = pub.y.slice(1);\n    }\n\n    if ((pub.x.length || pub.x.byteLength) > 48) {\n      pub.crv = 'P-521';\n    } else if ((pub.x.length || pub.x.byteLength) > 32) {\n      pub.crv = 'P-384';\n    } else {\n      pub.crv = 'P-256';\n    }\n\n    pub.x = Enc.bufToUrlBase64(pub.x);\n    pub.y = Enc.bufToUrlBase64(pub.y);\n  } else {\n    pub = req.children[2].children[1].children[0];\n    pub = {\n      kty: kty,\n      n: pub.children[0].value,\n      e: pub.children[1].value\n    };\n\n    while (0 === pub.n[0]) {\n      pub.n = pub.n.slice(1);\n    }\n\n    while (0 === pub.e[0]) {\n      pub.e = pub.e.slice(1);\n    }\n\n    pub.n = Enc.bufToUrlBase64(pub.n);\n    pub.e = Enc.bufToUrlBase64(pub.e);\n  } // 4 extensions\n\n\n  var domains = req.children[3].children.filter(function (seq) {\n    //  1.2.840.113549.1.9.14 extensionRequest (PKCS #9 via CRMF)\n    if ('2a864886f70d01090e' === Enc.bufToHex(seq.children[0].value)) {\n      return true;\n    }\n  }).map(function (seq) {\n    return seq.children[1].children[0].children.filter(function (seq2) {\n      // subjectAltName (X.509 extension)\n      if ('551d11' === Enc.bufToHex(seq2.children[0].value)) {\n        return true;\n      }\n    }).map(function (seq2) {\n      return seq2.children[1].children[0].children.map(function (name) {\n        // TODO utf8 => punycode\n        return Enc.bufToStr(name.value);\n      });\n    })[0];\n  })[0];\n  return {\n    subject: sub,\n    altnames: domains,\n    jwk: pub,\n    signature: sig\n  };\n};","map":{"version":3,"sources":["C:/Users/xuwen/Desktop/INFO340/project-2-xuwensi/node_modules/@root/csr/csr.js"],"names":["Enc","require","ASN1","Asn1","Any","BitStr","UInt","Asn1Parser","PEM","X509","Keypairs","CSR","module","exports","csr","opts","_prepare","then","create","bytes","_encode","Promise","resolve","JSON","parse","stringify","Error","Array","isArray","domains","length","every","d","jwk","key","kty","pem","import","pair","private","encoding","toLowerCase","packBlock","type","createCsr","hex","request","_sign","hexToBuf","createCsrBody","asn1pub","test","packCsrEcPublicKey","packCsrRsaPublicKey","packCsr","csrEcSig","sign","format","sig","_toDer","signature","encode","sty","bufToHex","asn1pubkey","strToHex","map","join","_info","der","parseBlock","base64ToBuf","c","verbose","json","children","value","req","sub","bufToStr","pub","slice","x","y","byteLength","crv","bufToUrlBase64","n","e","filter","seq","seq2","name","subject","altnames"],"mappings":"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","sourcesContent":["// Copyright 2018-present AJ ONeal. All rights reserved\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n'use strict';\n/*global Promise*/\n\nvar Enc = require('@root/encoding');\n\nvar ASN1 = require('@root/asn1/packer'); // DER, actually\nvar Asn1 = ASN1.Any;\nvar BitStr = ASN1.BitStr;\nvar UInt = ASN1.UInt;\nvar Asn1Parser = require('@root/asn1/parser');\nvar PEM = require('@root/pem');\nvar X509 = require('@root/x509');\n// TODO @root/keypairs/sign\nvar Keypairs = require('@root/keypairs');\n\n// TODO find a way that the prior node-ish way of `module.exports = function () {}` isn't broken\nvar CSR = module.exports;\n\n// { jwk, domains }\nCSR.csr = function(opts) {\n\t// We're using a Promise here to be compatible with the browser version\n\t// which will probably use the webcrypto API for some of the conversions\n\treturn CSR._prepare(opts).then(function(opts) {\n\t\treturn CSR.create(opts).then(function(bytes) {\n\t\t\treturn CSR._encode(opts, bytes);\n\t\t});\n\t});\n};\n\nCSR._prepare = function(opts) {\n\treturn Promise.resolve().then(function() {\n\t\topts = JSON.parse(JSON.stringify(opts));\n\n\t\t// We do a bit of extra error checking for user convenience\n\t\tif (!opts) {\n\t\t\tthrow new Error(\n\t\t\t\t'You must pass options with key and domains to rsacsr'\n\t\t\t);\n\t\t}\n\t\tif (!Array.isArray(opts.domains) || 0 === opts.domains.length) {\n\t\t\tnew Error('You must pass options.domains as a non-empty array');\n\t\t}\n\n\t\t// I need to check that 例.中国 is a valid domain name\n\t\tif (\n\t\t\t!opts.domains.every(function(d) {\n\t\t\t\t// allow punycode? xn--\n\t\t\t\tif (\n\t\t\t\t\t'string' === typeof d /*&& /\\./.test(d) && !/--/.test(d)*/\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t})\n\t\t) {\n\t\t\tthrow new Error('You must pass options.domains as strings');\n\t\t}\n\n\t\tif (opts.jwk) {\n\t\t\treturn opts;\n\t\t}\n\t\tif (opts.key && opts.key.kty) {\n\t\t\topts.jwk = opts.key;\n\t\t\treturn opts;\n\t\t}\n\t\tif (!opts.pem && !opts.key) {\n\t\t\tthrow new Error('You must pass options.key as a JSON web key');\n\t\t}\n\n\t\treturn Keypairs.import({ pem: opts.pem || opts.key }).then(function(\n\t\t\tpair\n\t\t) {\n\t\t\topts.jwk = pair.private;\n\t\t\treturn opts;\n\t\t});\n\t});\n};\n\nCSR._encode = function(opts, bytes) {\n\tif ('der' === (opts.encoding || '').toLowerCase()) {\n\t\treturn bytes;\n\t}\n\treturn PEM.packBlock({\n\t\ttype: 'CERTIFICATE REQUEST',\n\t\tbytes: bytes /* { jwk: jwk, domains: opts.domains } */\n\t});\n};\n\n// { jwk, domains }\nCSR.create = function createCsr(opts) {\n\tvar hex = CSR.request({\n\t\tjwk: opts.jwk,\n\t\tdomains: opts.domains,\n\t\tencoding: 'hex'\n\t});\n\treturn CSR._sign(opts.jwk, hex).then(function(csr) {\n\t\treturn Enc.hexToBuf(csr);\n\t});\n};\n\n//\n// EC / RSA\n//\n// { jwk, domains }\nCSR.request = function createCsrBody(opts) {\n\tvar asn1pub;\n\tif (/^EC/i.test(opts.jwk.kty)) {\n\t\tasn1pub = X509.packCsrEcPublicKey(opts.jwk);\n\t} else {\n\t\tasn1pub = X509.packCsrRsaPublicKey(opts.jwk);\n\t}\n\tvar hex = X509.packCsr(asn1pub, opts.domains);\n\tif ('hex' === opts.encoding) {\n\t\treturn hex;\n\t}\n\t// der\n\treturn Enc.hexToBuf(hex);\n};\n\nCSR._sign = function csrEcSig(jwk, request) {\n\t// Took some tips from https://gist.github.com/codermapuche/da4f96cdb6d5ff53b7ebc156ec46a10a\n\t// TODO will have to convert web ECDSA signatures to PEM ECDSA signatures (but RSA should be the same)\n\t// TODO have a consistent non-private way to sign\n\treturn Keypairs.sign(\n\t\t{ jwk: jwk, format: 'x509' },\n\t\tEnc.hexToBuf(request)\n\t).then(function(sig) {\n\t\treturn CSR._toDer({\n\t\t\trequest: request,\n\t\t\tsignature: sig,\n\t\t\tkty: jwk.kty\n\t\t});\n\t});\n};\n\nCSR._toDer = function encode(opts) {\n\tvar sty;\n\tif (/^EC/i.test(opts.kty)) {\n\t\t// 1.2.840.10045.4.3.2 ecdsaWithSHA256 (ANSI X9.62 ECDSA algorithm with SHA256)\n\t\tsty = Asn1('30', Asn1('06', '2a8648ce3d040302'));\n\t} else {\n\t\t// 1.2.840.113549.1.1.11 sha256WithRSAEncryption (PKCS #1)\n\t\tsty = Asn1('30', Asn1('06', '2a864886f70d01010b'), Asn1('05'));\n\t}\n\treturn Asn1(\n\t\t'30',\n\t\t// The Full CSR Request Body\n\t\topts.request,\n\t\t// The Signature Type\n\t\tsty,\n\t\t// The Signature\n\t\tBitStr(Enc.bufToHex(opts.signature))\n\t);\n};\n\nX509.packCsr = function(asn1pubkey, domains) {\n\treturn Asn1(\n\t\t'30',\n\t\t// Version (0)\n\t\tUInt('00'),\n\n\t\t// 2.5.4.3 commonName (X.520 DN component)\n\t\tAsn1(\n\t\t\t'30',\n\t\t\tAsn1(\n\t\t\t\t'31',\n\t\t\t\tAsn1(\n\t\t\t\t\t'30',\n\t\t\t\t\tAsn1('06', '550403'),\n\t\t\t\t\t// TODO utf8 => punycode\n\t\t\t\t\tAsn1('0c', Enc.strToHex(domains[0]))\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\n\t\t// Public Key (RSA or EC)\n\t\tasn1pubkey,\n\n\t\t// Request Body\n\t\tAsn1(\n\t\t\t'a0',\n\t\t\tAsn1(\n\t\t\t\t'30',\n\t\t\t\t// 1.2.840.113549.1.9.14 extensionRequest (PKCS #9 via CRMF)\n\t\t\t\tAsn1('06', '2a864886f70d01090e'),\n\t\t\t\tAsn1(\n\t\t\t\t\t'31',\n\t\t\t\t\tAsn1(\n\t\t\t\t\t\t'30',\n\t\t\t\t\t\tAsn1(\n\t\t\t\t\t\t\t'30',\n\t\t\t\t\t\t\t// 2.5.29.17 subjectAltName (X.509 extension)\n\t\t\t\t\t\t\tAsn1('06', '551d11'),\n\t\t\t\t\t\t\tAsn1(\n\t\t\t\t\t\t\t\t'04',\n\t\t\t\t\t\t\t\tAsn1(\n\t\t\t\t\t\t\t\t\t'30',\n\t\t\t\t\t\t\t\t\tdomains\n\t\t\t\t\t\t\t\t\t\t.map(function(d) {\n\t\t\t\t\t\t\t\t\t\t\t// TODO utf8 => punycode\n\t\t\t\t\t\t\t\t\t\t\treturn Asn1('82', Enc.strToHex(d));\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.join('')\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t);\n};\n\n// TODO finish this later\n// we want to parse the domains, the public key, and verify the signature\nCSR._info = function(der) {\n\t// standard base64 PEM\n\tif ('string' === typeof der && '-' === der[0]) {\n\t\tder = PEM.parseBlock(der).bytes;\n\t}\n\t// jose urlBase64 not-PEM\n\tif ('string' === typeof der) {\n\t\tder = Enc.base64ToBuf(der);\n\t}\n\t// not supporting binary-encoded base64\n\tvar c = Asn1Parser.parse({ der: der, verbose: true, json: false });\n\tvar kty;\n\t// A cert has 3 parts: cert, signature meta, signature\n\tif (c.children.length !== 3) {\n\t\tthrow new Error(\n\t\t\t\"doesn't look like a certificate request: expected 3 parts of header\"\n\t\t);\n\t}\n\tvar sig = c.children[2];\n\tif (sig.children.length) {\n\t\t// ASN1/X509 EC\n\t\tsig = sig.children[0];\n\t\tsig = Asn1(\n\t\t\t'30',\n\t\t\tUInt(Enc.bufToHex(sig.children[0].value)),\n\t\t\tUInt(Enc.bufToHex(sig.children[1].value))\n\t\t);\n\t\tsig = Enc.hexToBuf(sig);\n\t\tkty = 'EC';\n\t} else {\n\t\t// Raw RSA Sig\n\t\tsig = sig.value;\n\t\tkty = 'RSA';\n\t}\n\t//c.children[1]; // signature type\n\tvar req = c.children[0];\n\tif (4 !== req.children.length) {\n\t\tthrow new Error(\n\t\t\t\"doesn't look like a certificate request: expected 4 parts to request\"\n\t\t);\n\t}\n\t// 0 null\n\t// 1 commonName / subject\n\tvar sub = Enc.bufToStr(\n\t\treq.children[1].children[0].children[0].children[1].value\n\t);\n\t// 3 public key (type, key)\n\t//console.log('oid', Enc.bufToHex(req.children[2].children[0].children[0].value));\n\tvar pub;\n\t// TODO reuse ASN1 parser for these?\n\tif ('EC' === kty) {\n\t\t// throw away compression byte\n\t\tpub = req.children[2].children[1].value.slice(1);\n\t\tpub = { kty: kty, x: pub.slice(0, 32), y: pub.slice(32) };\n\t\twhile (0 === pub.x[0]) {\n\t\t\tpub.x = pub.x.slice(1);\n\t\t}\n\t\twhile (0 === pub.y[0]) {\n\t\t\tpub.y = pub.y.slice(1);\n\t\t}\n\t\tif ((pub.x.length || pub.x.byteLength) > 48) {\n\t\t\tpub.crv = 'P-521';\n\t\t} else if ((pub.x.length || pub.x.byteLength) > 32) {\n\t\t\tpub.crv = 'P-384';\n\t\t} else {\n\t\t\tpub.crv = 'P-256';\n\t\t}\n\t\tpub.x = Enc.bufToUrlBase64(pub.x);\n\t\tpub.y = Enc.bufToUrlBase64(pub.y);\n\t} else {\n\t\tpub = req.children[2].children[1].children[0];\n\t\tpub = {\n\t\t\tkty: kty,\n\t\t\tn: pub.children[0].value,\n\t\t\te: pub.children[1].value\n\t\t};\n\t\twhile (0 === pub.n[0]) {\n\t\t\tpub.n = pub.n.slice(1);\n\t\t}\n\t\twhile (0 === pub.e[0]) {\n\t\t\tpub.e = pub.e.slice(1);\n\t\t}\n\t\tpub.n = Enc.bufToUrlBase64(pub.n);\n\t\tpub.e = Enc.bufToUrlBase64(pub.e);\n\t}\n\t// 4 extensions\n\tvar domains = req.children[3].children\n\t\t.filter(function(seq) {\n\t\t\t//  1.2.840.113549.1.9.14 extensionRequest (PKCS #9 via CRMF)\n\t\t\tif ('2a864886f70d01090e' === Enc.bufToHex(seq.children[0].value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t})\n\t\t.map(function(seq) {\n\t\t\treturn seq.children[1].children[0].children\n\t\t\t\t.filter(function(seq2) {\n\t\t\t\t\t// subjectAltName (X.509 extension)\n\t\t\t\t\tif ('551d11' === Enc.bufToHex(seq2.children[0].value)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.map(function(seq2) {\n\t\t\t\t\treturn seq2.children[1].children[0].children.map(function(\n\t\t\t\t\t\tname\n\t\t\t\t\t) {\n\t\t\t\t\t\t// TODO utf8 => punycode\n\t\t\t\t\t\treturn Enc.bufToStr(name.value);\n\t\t\t\t\t});\n\t\t\t\t})[0];\n\t\t})[0];\n\n\treturn {\n\t\tsubject: sub,\n\t\taltnames: domains,\n\t\tjwk: pub,\n\t\tsignature: sig\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}