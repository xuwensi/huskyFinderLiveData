{"ast":null,"code":"'use strict';\n\nvar Keypairs = module.exports;\n\nKeypairs._sign = function (opts, payload) {\n  return Keypairs._import(opts).then(function (privkey) {\n    if ('string' === typeof payload) {\n      payload = new TextEncoder().encode(payload);\n    }\n\n    return window.crypto.subtle.sign({\n      name: Keypairs._getName(opts),\n      hash: {\n        name: 'SHA-' + Keypairs._getBits(opts)\n      }\n    }, privkey, payload).then(function (signature) {\n      signature = new Uint8Array(signature); // ArrayBuffer -> u8\n      // This will come back into play for CSRs, but not for JOSE\n\n      if ('EC' === opts.jwk.kty && /x509|asn1/i.test(opts.format)) {\n        return Keypairs._ecdsaJoseSigToAsn1Sig(signature);\n      } else {\n        // jose/jws/jwt\n        return signature;\n      }\n    });\n  });\n};\n\nKeypairs._import = function (opts) {\n  return Promise.resolve().then(function () {\n    var ops; // all private keys just happen to have a 'd'\n\n    if (opts.jwk.d) {\n      ops = ['sign'];\n    } else {\n      ops = ['verify'];\n    } // gotta mark it as extractable, as if it matters\n\n\n    opts.jwk.ext = true;\n    opts.jwk.key_ops = ops;\n    return window.crypto.subtle.importKey('jwk', opts.jwk, {\n      name: Keypairs._getName(opts),\n      namedCurve: opts.jwk.crv,\n      hash: {\n        name: 'SHA-' + Keypairs._getBits(opts)\n      }\n    }, true, ops).then(function (privkey) {\n      delete opts.jwk.ext;\n      return privkey;\n    });\n  });\n}; // ECDSA JOSE / JWS / JWT signatures differ from \"normal\" ASN1/X509 ECDSA signatures\n// https://tools.ietf.org/html/rfc7518#section-3.4\n\n\nKeypairs._ecdsaJoseSigToAsn1Sig = function (bufsig) {\n  // it's easier to do the manipulation in the browser with an array\n  bufsig = Array.from(bufsig);\n  var hlen = bufsig.length / 2; // should be even\n\n  var r = bufsig.slice(0, hlen);\n  var s = bufsig.slice(hlen); // unpad positive ints less than 32 bytes wide\n\n  while (!r[0]) {\n    r = r.slice(1);\n  }\n\n  while (!s[0]) {\n    s = s.slice(1);\n  } // pad (or re-pad) ambiguously non-negative BigInts, up to 33 bytes wide\n\n\n  if (0x80 & r[0]) {\n    r.unshift(0);\n  }\n\n  if (0x80 & s[0]) {\n    s.unshift(0);\n  }\n\n  var len = 2 + r.length + 2 + s.length;\n  var head = [0x30]; // hard code 0x80 + 1 because it won't be longer than\n  // two SHA512 plus two pad bytes (130 bytes <= 256)\n\n  if (len >= 0x80) {\n    head.push(0x81);\n  }\n\n  head.push(len);\n  return Uint8Array.from(head.concat([0x02, r.length], r, [0x02, s.length], s));\n};\n\nKeypairs._getName = function (opts) {\n  if (/EC/i.test(opts.jwk.kty)) {\n    return 'ECDSA';\n  } else {\n    return 'RSASSA-PKCS1-v1_5';\n  }\n};","map":{"version":3,"sources":["C:/Users/xuwen/Desktop/INFO340/project-2-xuwensi/node_modules/@root/keypairs/lib/browser/keypairs.js"],"names":["Keypairs","module","exports","_sign","opts","payload","_import","then","privkey","TextEncoder","encode","window","crypto","subtle","sign","name","_getName","hash","_getBits","signature","Uint8Array","jwk","kty","test","format","_ecdsaJoseSigToAsn1Sig","Promise","resolve","ops","d","ext","key_ops","importKey","namedCurve","crv","bufsig","Array","from","hlen","length","r","slice","s","unshift","len","head","push","concat"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,OAAtB;;AAEAF,QAAQ,CAACG,KAAT,GAAiB,UAASC,IAAT,EAAeC,OAAf,EAAwB;AACxC,SAAOL,QAAQ,CAACM,OAAT,CAAiBF,IAAjB,EAAuBG,IAAvB,CAA4B,UAASC,OAAT,EAAkB;AACpD,QAAI,aAAa,OAAOH,OAAxB,EAAiC;AAChCA,MAAAA,OAAO,GAAG,IAAII,WAAJ,GAAkBC,MAAlB,CAAyBL,OAAzB,CAAV;AACA;;AAED,WAAOM,MAAM,CAACC,MAAP,CAAcC,MAAd,CACLC,IADK,CAEL;AACCC,MAAAA,IAAI,EAAEf,QAAQ,CAACgB,QAAT,CAAkBZ,IAAlB,CADP;AAECa,MAAAA,IAAI,EAAE;AAAEF,QAAAA,IAAI,EAAE,SAASf,QAAQ,CAACkB,QAAT,CAAkBd,IAAlB;AAAjB;AAFP,KAFK,EAMLI,OANK,EAOLH,OAPK,EASLE,IATK,CASA,UAASY,SAAT,EAAoB;AACzBA,MAAAA,SAAS,GAAG,IAAIC,UAAJ,CAAeD,SAAf,CAAZ,CADyB,CACc;AACvC;;AACA,UAAI,SAASf,IAAI,CAACiB,GAAL,CAASC,GAAlB,IAAyB,aAAaC,IAAb,CAAkBnB,IAAI,CAACoB,MAAvB,CAA7B,EAA6D;AAC5D,eAAOxB,QAAQ,CAACyB,sBAAT,CAAgCN,SAAhC,CAAP;AACA,OAFD,MAEO;AACN;AACA,eAAOA,SAAP;AACA;AACD,KAlBK,CAAP;AAmBA,GAxBM,CAAP;AAyBA,CA1BD;;AA4BAnB,QAAQ,CAACM,OAAT,GAAmB,UAASF,IAAT,EAAe;AACjC,SAAOsB,OAAO,CAACC,OAAR,GAAkBpB,IAAlB,CAAuB,YAAW;AACxC,QAAIqB,GAAJ,CADwC,CAExC;;AACA,QAAIxB,IAAI,CAACiB,GAAL,CAASQ,CAAb,EAAgB;AACfD,MAAAA,GAAG,GAAG,CAAC,MAAD,CAAN;AACA,KAFD,MAEO;AACNA,MAAAA,GAAG,GAAG,CAAC,QAAD,CAAN;AACA,KAPuC,CAQxC;;;AACAxB,IAAAA,IAAI,CAACiB,GAAL,CAASS,GAAT,GAAe,IAAf;AACA1B,IAAAA,IAAI,CAACiB,GAAL,CAASU,OAAT,GAAmBH,GAAnB;AAEA,WAAOjB,MAAM,CAACC,MAAP,CAAcC,MAAd,CACLmB,SADK,CAEL,KAFK,EAGL5B,IAAI,CAACiB,GAHA,EAIL;AACCN,MAAAA,IAAI,EAAEf,QAAQ,CAACgB,QAAT,CAAkBZ,IAAlB,CADP;AAEC6B,MAAAA,UAAU,EAAE7B,IAAI,CAACiB,GAAL,CAASa,GAFtB;AAGCjB,MAAAA,IAAI,EAAE;AAAEF,QAAAA,IAAI,EAAE,SAASf,QAAQ,CAACkB,QAAT,CAAkBd,IAAlB;AAAjB;AAHP,KAJK,EASL,IATK,EAULwB,GAVK,EAYLrB,IAZK,CAYA,UAASC,OAAT,EAAkB;AACvB,aAAOJ,IAAI,CAACiB,GAAL,CAASS,GAAhB;AACA,aAAOtB,OAAP;AACA,KAfK,CAAP;AAgBA,GA5BM,CAAP;AA6BA,CA9BD,C,CAgCA;AACA;;;AACAR,QAAQ,CAACyB,sBAAT,GAAkC,UAASU,MAAT,EAAiB;AAClD;AACAA,EAAAA,MAAM,GAAGC,KAAK,CAACC,IAAN,CAAWF,MAAX,CAAT;AACA,MAAIG,IAAI,GAAGH,MAAM,CAACI,MAAP,GAAgB,CAA3B,CAHkD,CAGpB;;AAC9B,MAAIC,CAAC,GAAGL,MAAM,CAACM,KAAP,CAAa,CAAb,EAAgBH,IAAhB,CAAR;AACA,MAAII,CAAC,GAAGP,MAAM,CAACM,KAAP,CAAaH,IAAb,CAAR,CALkD,CAMlD;;AACA,SAAO,CAACE,CAAC,CAAC,CAAD,CAAT,EAAc;AACbA,IAAAA,CAAC,GAAGA,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAJ;AACA;;AACD,SAAO,CAACC,CAAC,CAAC,CAAD,CAAT,EAAc;AACbA,IAAAA,CAAC,GAAGA,CAAC,CAACD,KAAF,CAAQ,CAAR,CAAJ;AACA,GAZiD,CAalD;;;AACA,MAAI,OAAOD,CAAC,CAAC,CAAD,CAAZ,EAAiB;AAChBA,IAAAA,CAAC,CAACG,OAAF,CAAU,CAAV;AACA;;AACD,MAAI,OAAOD,CAAC,CAAC,CAAD,CAAZ,EAAiB;AAChBA,IAAAA,CAAC,CAACC,OAAF,CAAU,CAAV;AACA;;AAED,MAAIC,GAAG,GAAG,IAAIJ,CAAC,CAACD,MAAN,GAAe,CAAf,GAAmBG,CAAC,CAACH,MAA/B;AACA,MAAIM,IAAI,GAAG,CAAC,IAAD,CAAX,CAtBkD,CAuBlD;AACA;;AACA,MAAID,GAAG,IAAI,IAAX,EAAiB;AAChBC,IAAAA,IAAI,CAACC,IAAL,CAAU,IAAV;AACA;;AACDD,EAAAA,IAAI,CAACC,IAAL,CAAUF,GAAV;AAEA,SAAOxB,UAAU,CAACiB,IAAX,CACNQ,IAAI,CAACE,MAAL,CAAY,CAAC,IAAD,EAAOP,CAAC,CAACD,MAAT,CAAZ,EAA8BC,CAA9B,EAAiC,CAAC,IAAD,EAAOE,CAAC,CAACH,MAAT,CAAjC,EAAmDG,CAAnD,CADM,CAAP;AAGA,CAjCD;;AAmCA1C,QAAQ,CAACgB,QAAT,GAAoB,UAASZ,IAAT,EAAe;AAClC,MAAI,MAAMmB,IAAN,CAAWnB,IAAI,CAACiB,GAAL,CAASC,GAApB,CAAJ,EAA8B;AAC7B,WAAO,OAAP;AACA,GAFD,MAEO;AACN,WAAO,mBAAP;AACA;AACD,CAND","sourcesContent":["'use strict';\n\nvar Keypairs = module.exports;\n\nKeypairs._sign = function(opts, payload) {\n\treturn Keypairs._import(opts).then(function(privkey) {\n\t\tif ('string' === typeof payload) {\n\t\t\tpayload = new TextEncoder().encode(payload);\n\t\t}\n\n\t\treturn window.crypto.subtle\n\t\t\t.sign(\n\t\t\t\t{\n\t\t\t\t\tname: Keypairs._getName(opts),\n\t\t\t\t\thash: { name: 'SHA-' + Keypairs._getBits(opts) }\n\t\t\t\t},\n\t\t\t\tprivkey,\n\t\t\t\tpayload\n\t\t\t)\n\t\t\t.then(function(signature) {\n\t\t\t\tsignature = new Uint8Array(signature); // ArrayBuffer -> u8\n\t\t\t\t// This will come back into play for CSRs, but not for JOSE\n\t\t\t\tif ('EC' === opts.jwk.kty && /x509|asn1/i.test(opts.format)) {\n\t\t\t\t\treturn Keypairs._ecdsaJoseSigToAsn1Sig(signature);\n\t\t\t\t} else {\n\t\t\t\t\t// jose/jws/jwt\n\t\t\t\t\treturn signature;\n\t\t\t\t}\n\t\t\t});\n\t});\n};\n\nKeypairs._import = function(opts) {\n\treturn Promise.resolve().then(function() {\n\t\tvar ops;\n\t\t// all private keys just happen to have a 'd'\n\t\tif (opts.jwk.d) {\n\t\t\tops = ['sign'];\n\t\t} else {\n\t\t\tops = ['verify'];\n\t\t}\n\t\t// gotta mark it as extractable, as if it matters\n\t\topts.jwk.ext = true;\n\t\topts.jwk.key_ops = ops;\n\n\t\treturn window.crypto.subtle\n\t\t\t.importKey(\n\t\t\t\t'jwk',\n\t\t\t\topts.jwk,\n\t\t\t\t{\n\t\t\t\t\tname: Keypairs._getName(opts),\n\t\t\t\t\tnamedCurve: opts.jwk.crv,\n\t\t\t\t\thash: { name: 'SHA-' + Keypairs._getBits(opts) }\n\t\t\t\t},\n\t\t\t\ttrue,\n\t\t\t\tops\n\t\t\t)\n\t\t\t.then(function(privkey) {\n\t\t\t\tdelete opts.jwk.ext;\n\t\t\t\treturn privkey;\n\t\t\t});\n\t});\n};\n\n// ECDSA JOSE / JWS / JWT signatures differ from \"normal\" ASN1/X509 ECDSA signatures\n// https://tools.ietf.org/html/rfc7518#section-3.4\nKeypairs._ecdsaJoseSigToAsn1Sig = function(bufsig) {\n\t// it's easier to do the manipulation in the browser with an array\n\tbufsig = Array.from(bufsig);\n\tvar hlen = bufsig.length / 2; // should be even\n\tvar r = bufsig.slice(0, hlen);\n\tvar s = bufsig.slice(hlen);\n\t// unpad positive ints less than 32 bytes wide\n\twhile (!r[0]) {\n\t\tr = r.slice(1);\n\t}\n\twhile (!s[0]) {\n\t\ts = s.slice(1);\n\t}\n\t// pad (or re-pad) ambiguously non-negative BigInts, up to 33 bytes wide\n\tif (0x80 & r[0]) {\n\t\tr.unshift(0);\n\t}\n\tif (0x80 & s[0]) {\n\t\ts.unshift(0);\n\t}\n\n\tvar len = 2 + r.length + 2 + s.length;\n\tvar head = [0x30];\n\t// hard code 0x80 + 1 because it won't be longer than\n\t// two SHA512 plus two pad bytes (130 bytes <= 256)\n\tif (len >= 0x80) {\n\t\thead.push(0x81);\n\t}\n\thead.push(len);\n\n\treturn Uint8Array.from(\n\t\thead.concat([0x02, r.length], r, [0x02, s.length], s)\n\t);\n};\n\nKeypairs._getName = function(opts) {\n\tif (/EC/i.test(opts.jwk.kty)) {\n\t\treturn 'ECDSA';\n\t} else {\n\t\treturn 'RSASSA-PKCS1-v1_5';\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}