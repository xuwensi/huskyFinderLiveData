{"ast":null,"code":"'use strict';\n\nvar native = module.exports; // XXX added by caller: _stance, neuter\n\nvar RSA = native;\n\nnative.generate = function (opts) {\n  var wcOpts = {};\n\n  if (!opts) {\n    opts = {};\n  }\n\n  if (!opts.kty) {\n    opts.kty = 'RSA';\n  } // Support PSS? I don't think it's used for Let's Encrypt\n\n\n  wcOpts.name = 'RSASSA-PKCS1-v1_5';\n\n  if (!opts.modulusLength) {\n    opts.modulusLength = 2048;\n  }\n\n  wcOpts.modulusLength = opts.modulusLength;\n\n  if (wcOpts.modulusLength >= 2048 && wcOpts.modulusLength < 3072) {\n    // erring on the small side... for no good reason\n    wcOpts.hash = {\n      name: 'SHA-256'\n    };\n  } else if (wcOpts.modulusLength >= 3072 && wcOpts.modulusLength < 4096) {\n    wcOpts.hash = {\n      name: 'SHA-384'\n    };\n  } else if (wcOpts.modulusLength < 4097) {\n    wcOpts.hash = {\n      name: 'SHA-512'\n    };\n  } else {\n    // Public key thumbprints should be paired with a hash of similar length,\n    // so anything above SHA-512's keyspace would be left under-represented anyway.\n    return Promise.Reject(new Error(\"'\" + wcOpts.modulusLength + \"' is not within the safe and universally\" + ' acceptable range of 2048-4096. Typically you should pick 2048, 3072, or 4096, though other values' + ' divisible by 8 are allowed. ' + RSA._stance));\n  } // TODO maybe allow this to be set to any of the standard values?\n\n\n  wcOpts.publicExponent = new Uint8Array([0x01, 0x00, 0x01]);\n  var extractable = true;\n  return window.crypto.subtle.generateKey(wcOpts, extractable, ['sign', 'verify']).then(function (result) {\n    return window.crypto.subtle.exportKey('jwk', result.privateKey).then(function (privJwk) {\n      return {\n        private: privJwk,\n        public: RSA.neuter({\n          jwk: privJwk\n        })\n      };\n    });\n  });\n};","map":{"version":3,"sources":["C:/Users/xuwen/Desktop/INFO340/project-2-xuwensi/node_modules/@root/keypairs/lib/browser/rsa.js"],"names":["native","module","exports","RSA","generate","opts","wcOpts","kty","name","modulusLength","hash","Promise","Reject","Error","_stance","publicExponent","Uint8Array","extractable","window","crypto","subtle","generateKey","then","result","exportKey","privateKey","privJwk","private","public","neuter","jwk"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,MAAM,CAACC,OAApB,C,CACA;;AACA,IAAIC,GAAG,GAAGH,MAAV;;AAEAA,MAAM,CAACI,QAAP,GAAkB,UAASC,IAAT,EAAe;AAChC,MAAIC,MAAM,GAAG,EAAb;;AACA,MAAI,CAACD,IAAL,EAAW;AACVA,IAAAA,IAAI,GAAG,EAAP;AACA;;AACD,MAAI,CAACA,IAAI,CAACE,GAAV,EAAe;AACdF,IAAAA,IAAI,CAACE,GAAL,GAAW,KAAX;AACA,GAP+B,CAShC;;;AACAD,EAAAA,MAAM,CAACE,IAAP,GAAc,mBAAd;;AACA,MAAI,CAACH,IAAI,CAACI,aAAV,EAAyB;AACxBJ,IAAAA,IAAI,CAACI,aAAL,GAAqB,IAArB;AACA;;AACDH,EAAAA,MAAM,CAACG,aAAP,GAAuBJ,IAAI,CAACI,aAA5B;;AACA,MAAIH,MAAM,CAACG,aAAP,IAAwB,IAAxB,IAAgCH,MAAM,CAACG,aAAP,GAAuB,IAA3D,EAAiE;AAChE;AACAH,IAAAA,MAAM,CAACI,IAAP,GAAc;AAAEF,MAAAA,IAAI,EAAE;AAAR,KAAd;AACA,GAHD,MAGO,IAAIF,MAAM,CAACG,aAAP,IAAwB,IAAxB,IAAgCH,MAAM,CAACG,aAAP,GAAuB,IAA3D,EAAiE;AACvEH,IAAAA,MAAM,CAACI,IAAP,GAAc;AAAEF,MAAAA,IAAI,EAAE;AAAR,KAAd;AACA,GAFM,MAEA,IAAIF,MAAM,CAACG,aAAP,GAAuB,IAA3B,EAAiC;AACvCH,IAAAA,MAAM,CAACI,IAAP,GAAc;AAAEF,MAAAA,IAAI,EAAE;AAAR,KAAd;AACA,GAFM,MAEA;AACN;AACA;AACA,WAAOG,OAAO,CAACC,MAAR,CACN,IAAIC,KAAJ,CACC,MACCP,MAAM,CAACG,aADR,GAEC,0CAFD,GAGC,oGAHD,GAIC,+BAJD,GAKCN,GAAG,CAACW,OANN,CADM,CAAP;AAUA,GAnC+B,CAoChC;;;AACAR,EAAAA,MAAM,CAACS,cAAP,GAAwB,IAAIC,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAAxB;AAEA,MAAIC,WAAW,GAAG,IAAlB;AACA,SAAOC,MAAM,CAACC,MAAP,CAAcC,MAAd,CACLC,WADK,CACOf,MADP,EACeW,WADf,EAC4B,CAAC,MAAD,EAAS,QAAT,CAD5B,EAELK,IAFK,CAEA,UAASC,MAAT,EAAiB;AACtB,WAAOL,MAAM,CAACC,MAAP,CAAcC,MAAd,CACLI,SADK,CACK,KADL,EACYD,MAAM,CAACE,UADnB,EAELH,IAFK,CAEA,UAASI,OAAT,EAAkB;AACvB,aAAO;AACNC,QAAAA,OAAO,EAAED,OADH;AAENE,QAAAA,MAAM,EAAEzB,GAAG,CAAC0B,MAAJ,CAAW;AAAEC,UAAAA,GAAG,EAAEJ;AAAP,SAAX;AAFF,OAAP;AAIA,KAPK,CAAP;AAQA,GAXK,CAAP;AAYA,CApDD","sourcesContent":["'use strict';\n\nvar native = module.exports;\n// XXX added by caller: _stance, neuter\nvar RSA = native;\n\nnative.generate = function(opts) {\n\tvar wcOpts = {};\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tif (!opts.kty) {\n\t\topts.kty = 'RSA';\n\t}\n\n\t// Support PSS? I don't think it's used for Let's Encrypt\n\twcOpts.name = 'RSASSA-PKCS1-v1_5';\n\tif (!opts.modulusLength) {\n\t\topts.modulusLength = 2048;\n\t}\n\twcOpts.modulusLength = opts.modulusLength;\n\tif (wcOpts.modulusLength >= 2048 && wcOpts.modulusLength < 3072) {\n\t\t// erring on the small side... for no good reason\n\t\twcOpts.hash = { name: 'SHA-256' };\n\t} else if (wcOpts.modulusLength >= 3072 && wcOpts.modulusLength < 4096) {\n\t\twcOpts.hash = { name: 'SHA-384' };\n\t} else if (wcOpts.modulusLength < 4097) {\n\t\twcOpts.hash = { name: 'SHA-512' };\n\t} else {\n\t\t// Public key thumbprints should be paired with a hash of similar length,\n\t\t// so anything above SHA-512's keyspace would be left under-represented anyway.\n\t\treturn Promise.Reject(\n\t\t\tnew Error(\n\t\t\t\t\"'\" +\n\t\t\t\t\twcOpts.modulusLength +\n\t\t\t\t\t\"' is not within the safe and universally\" +\n\t\t\t\t\t' acceptable range of 2048-4096. Typically you should pick 2048, 3072, or 4096, though other values' +\n\t\t\t\t\t' divisible by 8 are allowed. ' +\n\t\t\t\t\tRSA._stance\n\t\t\t)\n\t\t);\n\t}\n\t// TODO maybe allow this to be set to any of the standard values?\n\twcOpts.publicExponent = new Uint8Array([0x01, 0x00, 0x01]);\n\n\tvar extractable = true;\n\treturn window.crypto.subtle\n\t\t.generateKey(wcOpts, extractable, ['sign', 'verify'])\n\t\t.then(function(result) {\n\t\t\treturn window.crypto.subtle\n\t\t\t\t.exportKey('jwk', result.privateKey)\n\t\t\t\t.then(function(privJwk) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprivate: privJwk,\n\t\t\t\t\t\tpublic: RSA.neuter({ jwk: privJwk })\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t});\n};\n"]},"metadata":{},"sourceType":"script"}