{"ast":null,"code":"'use strict';\n\nvar Enc = module.exports; // to Binary String\n\nEnc.bufToBin = function (buf) {\n  var bin = ''; // cannot use .map() because Uint8Array would return only 0s\n\n  buf.forEach(function (ch) {\n    bin += String.fromCharCode(ch);\n  });\n  return bin;\n};\n\nEnc.strToBin = function (str) {\n  // Note: TextEncoder might be faster (or it might be slower, I don't know),\n  // but it doesn't solve the double-utf8 problem and MS Edge still has users without it\n  var escstr = encodeURIComponent(str); // replaces any uri escape sequence, such as %0A,\n  // with binary escape, such as 0x0A\n\n  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (_, p1) {\n    return String.fromCharCode('0x' + p1);\n  });\n  return binstr;\n}; // to Buffer\n\n\nEnc.binToBuf = function (bin) {\n  var arr = bin.split('').map(function (ch) {\n    return ch.charCodeAt(0);\n  });\n  return 'undefined' !== typeof Uint8Array ? new Uint8Array(arr) : arr;\n};\n\nEnc.strToBuf = function (str) {\n  return Enc.binToBuf(Enc.strToBin(str));\n}; // to Unicode String\n\n\nEnc.binToStr = function (binstr) {\n  var escstr = binstr.replace(/(.)/g, function (m, p) {\n    var code = p.charCodeAt(0).toString(16).toUpperCase();\n\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n\n    return '%' + code;\n  });\n  return decodeURIComponent(escstr);\n};\n\nEnc.bufToStr = function (buf) {\n  return Enc.binToStr(Enc.bufToBin(buf));\n}; // Base64 + Hex\n\n\nEnc.base64ToHex = function (b64) {\n  return Enc.bufToHex(Enc.base64ToBuf(b64));\n};\n\nEnc.hexToBase64 = function (hex) {\n  return btoa(Enc._hexToBin(hex));\n};","map":{"version":3,"sources":["C:/Users/xuwen/Desktop/INFO340/project-2-xuwensi/node_modules/@root/encoding/browser/bytes.js"],"names":["Enc","module","exports","bufToBin","buf","bin","forEach","ch","String","fromCharCode","strToBin","str","escstr","encodeURIComponent","binstr","replace","_","p1","binToBuf","arr","split","map","charCodeAt","Uint8Array","strToBuf","binToStr","m","p","code","toString","toUpperCase","length","decodeURIComponent","bufToStr","base64ToHex","b64","bufToHex","base64ToBuf","hexToBase64","hex","btoa","_hexToBin"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,MAAM,CAACC,OAAjB,C,CAEA;;AAEAF,GAAG,CAACG,QAAJ,GAAe,UAASC,GAAT,EAAc;AAC5B,MAAIC,GAAG,GAAG,EAAV,CAD4B,CAE5B;;AACAD,EAAAA,GAAG,CAACE,OAAJ,CAAY,UAASC,EAAT,EAAa;AACxBF,IAAAA,GAAG,IAAIG,MAAM,CAACC,YAAP,CAAoBF,EAApB,CAAP;AACA,GAFD;AAGA,SAAOF,GAAP;AACA,CAPD;;AASAL,GAAG,CAACU,QAAJ,GAAe,UAASC,GAAT,EAAc;AAC5B;AACA;AACA,MAAIC,MAAM,GAAGC,kBAAkB,CAACF,GAAD,CAA/B,CAH4B,CAI5B;AACA;;AACA,MAAIG,MAAM,GAAGF,MAAM,CAACG,OAAP,CAAe,iBAAf,EAAkC,UAASC,CAAT,EAAYC,EAAZ,EAAgB;AAC9D,WAAOT,MAAM,CAACC,YAAP,CAAoB,OAAOQ,EAA3B,CAAP;AACA,GAFY,CAAb;AAGA,SAAOH,MAAP;AACA,CAVD,C,CAYA;;;AAEAd,GAAG,CAACkB,QAAJ,GAAe,UAASb,GAAT,EAAc;AAC5B,MAAIc,GAAG,GAAGd,GAAG,CAACe,KAAJ,CAAU,EAAV,EAAcC,GAAd,CAAkB,UAASd,EAAT,EAAa;AACxC,WAAOA,EAAE,CAACe,UAAH,CAAc,CAAd,CAAP;AACA,GAFS,CAAV;AAGA,SAAO,gBAAgB,OAAOC,UAAvB,GAAoC,IAAIA,UAAJ,CAAeJ,GAAf,CAApC,GAA0DA,GAAjE;AACA,CALD;;AAOAnB,GAAG,CAACwB,QAAJ,GAAe,UAASb,GAAT,EAAc;AAC5B,SAAOX,GAAG,CAACkB,QAAJ,CAAalB,GAAG,CAACU,QAAJ,CAAaC,GAAb,CAAb,CAAP;AACA,CAFD,C,CAIA;;;AAEAX,GAAG,CAACyB,QAAJ,GAAe,UAASX,MAAT,EAAiB;AAC/B,MAAIF,MAAM,GAAGE,MAAM,CAACC,OAAP,CAAe,MAAf,EAAuB,UAASW,CAAT,EAAYC,CAAZ,EAAe;AAClD,QAAIC,IAAI,GAAGD,CAAC,CACVL,UADS,CACE,CADF,EAETO,QAFS,CAEA,EAFA,EAGTC,WAHS,EAAX;;AAIA,QAAIF,IAAI,CAACG,MAAL,GAAc,CAAlB,EAAqB;AACpBH,MAAAA,IAAI,GAAG,MAAMA,IAAb;AACA;;AACD,WAAO,MAAMA,IAAb;AACA,GATY,CAAb;AAWA,SAAOI,kBAAkB,CAACpB,MAAD,CAAzB;AACA,CAbD;;AAeAZ,GAAG,CAACiC,QAAJ,GAAe,UAAS7B,GAAT,EAAc;AAC5B,SAAOJ,GAAG,CAACyB,QAAJ,CAAazB,GAAG,CAACG,QAAJ,CAAaC,GAAb,CAAb,CAAP;AACA,CAFD,C,CAIA;;;AAEAJ,GAAG,CAACkC,WAAJ,GAAkB,UAASC,GAAT,EAAc;AAC/B,SAAOnC,GAAG,CAACoC,QAAJ,CAAapC,GAAG,CAACqC,WAAJ,CAAgBF,GAAhB,CAAb,CAAP;AACA,CAFD;;AAIAnC,GAAG,CAACsC,WAAJ,GAAkB,UAASC,GAAT,EAAc;AAC/B,SAAOC,IAAI,CAACxC,GAAG,CAACyC,SAAJ,CAAcF,GAAd,CAAD,CAAX;AACA,CAFD","sourcesContent":["'use strict';\n\nvar Enc = module.exports;\n\n// to Binary String\n\nEnc.bufToBin = function(buf) {\n\tvar bin = '';\n\t// cannot use .map() because Uint8Array would return only 0s\n\tbuf.forEach(function(ch) {\n\t\tbin += String.fromCharCode(ch);\n\t});\n\treturn bin;\n};\n\nEnc.strToBin = function(str) {\n\t// Note: TextEncoder might be faster (or it might be slower, I don't know),\n\t// but it doesn't solve the double-utf8 problem and MS Edge still has users without it\n\tvar escstr = encodeURIComponent(str);\n\t// replaces any uri escape sequence, such as %0A,\n\t// with binary escape, such as 0x0A\n\tvar binstr = escstr.replace(/%([0-9A-F]{2})/g, function(_, p1) {\n\t\treturn String.fromCharCode('0x' + p1);\n\t});\n\treturn binstr;\n};\n\n// to Buffer\n\nEnc.binToBuf = function(bin) {\n\tvar arr = bin.split('').map(function(ch) {\n\t\treturn ch.charCodeAt(0);\n\t});\n\treturn 'undefined' !== typeof Uint8Array ? new Uint8Array(arr) : arr;\n};\n\nEnc.strToBuf = function(str) {\n\treturn Enc.binToBuf(Enc.strToBin(str));\n};\n\n// to Unicode String\n\nEnc.binToStr = function(binstr) {\n\tvar escstr = binstr.replace(/(.)/g, function(m, p) {\n\t\tvar code = p\n\t\t\t.charCodeAt(0)\n\t\t\t.toString(16)\n\t\t\t.toUpperCase();\n\t\tif (code.length < 2) {\n\t\t\tcode = '0' + code;\n\t\t}\n\t\treturn '%' + code;\n\t});\n\n\treturn decodeURIComponent(escstr);\n};\n\nEnc.bufToStr = function(buf) {\n\treturn Enc.binToStr(Enc.bufToBin(buf));\n};\n\n// Base64 + Hex\n\nEnc.base64ToHex = function(b64) {\n\treturn Enc.bufToHex(Enc.base64ToBuf(b64));\n};\n\nEnc.hexToBase64 = function(hex) {\n\treturn btoa(Enc._hexToBin(hex));\n};\n"]},"metadata":{},"sourceType":"script"}