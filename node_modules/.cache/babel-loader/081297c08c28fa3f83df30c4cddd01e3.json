{"ast":null,"code":"/*global Promise*/\n'use strict';\n\nvar RSA = module.exports;\n\nvar native = require('./lib/node/rsa.js');\n\nvar X509 = require('@root/x509');\n\nvar PEM = require('@root/pem'); //var SSH = require('./ssh-keys.js');\n\n\nvar sha2 = require('./lib/node/sha2.js');\n\nvar Enc = require('@root/encoding/base64');\n\nRSA._universal = 'Bluecrypt only supports crypto with standard cross-browser and cross-platform support.';\nRSA._stance = \"We take the stance that if you're knowledgeable enough to\" + \" properly and securely use non-standard crypto then you shouldn't need Bluecrypt anyway.\";\nnative._stance = RSA._stance;\nRSA.generate = native.generate; // Chopping off the private parts is now part of the public API.\n// I thought it sounded a little too crude at first, but it really is the best name in every possible way.\n\nRSA.neuter = function (opts) {\n  // trying to find the best balance of an immutable copy with custom attributes\n  var jwk = {};\n  Object.keys(opts.jwk).forEach(function (k) {\n    if ('undefined' === typeof opts.jwk[k]) {\n      return;\n    } // ignore RSA private parts\n\n\n    if (-1 !== ['d', 'p', 'q', 'dp', 'dq', 'qi'].indexOf(k)) {\n      return;\n    }\n\n    jwk[k] = JSON.parse(JSON.stringify(opts.jwk[k]));\n  });\n  return jwk;\n};\n\nnative.neuter = RSA.neuter; // https://stackoverflow.com/questions/42588786/how-to-fingerprint-a-jwk\n\nRSA.__thumbprint = function (jwk) {\n  // Use the same entropy for SHA as for key\n  var len = Math.floor(jwk.n.length * 0.75);\n  var alg = 'SHA-256'; // TODO this may be a bug\n  // need to confirm that the padding is no more or less than 1 byte\n\n  if (len >= 511) {\n    alg = 'SHA-512';\n  } else if (len >= 383) {\n    alg = 'SHA-384';\n  }\n\n  return sha2.sum(alg, '{\"e\":\"' + jwk.e + '\",\"kty\":\"RSA\",\"n\":\"' + jwk.n + '\"}').then(function (hash) {\n    return Enc.bufToUrlBase64(Uint8Array.from(hash));\n  });\n};\n\nRSA.thumbprint = function (opts) {\n  return Promise.resolve().then(function () {\n    var jwk;\n\n    if ('EC' === opts.kty) {\n      jwk = opts;\n    } else if (opts.jwk) {\n      jwk = opts.jwk;\n    } else {\n      return RSA.import(opts).then(function (jwk) {\n        return RSA.__thumbprint(jwk);\n      });\n    }\n\n    return RSA.__thumbprint(jwk);\n  });\n};\n\nRSA.export = function (opts) {\n  return Promise.resolve().then(function () {\n    if (!opts || !opts.jwk || 'object' !== typeof opts.jwk) {\n      throw new Error('must pass { jwk: jwk }');\n    }\n\n    var jwk = JSON.parse(JSON.stringify(opts.jwk));\n    var format = opts.format;\n    var pub = opts.public;\n\n    if (pub || -1 !== ['spki', 'pkix', 'ssh', 'rfc4716'].indexOf(format)) {\n      jwk = RSA.neuter({\n        jwk: jwk\n      });\n    }\n\n    if ('RSA' !== jwk.kty) {\n      throw new Error(\"options.jwk.kty must be 'RSA' for RSA keys: \" + JSON.stringify(jwk));\n    }\n\n    if (!jwk.p) {\n      // TODO test for n and e\n      pub = true;\n\n      if (!format || 'pkcs1' === format) {\n        format = 'pkcs1';\n      } else if (-1 !== ['spki', 'pkix'].indexOf(format)) {\n        format = 'spki';\n      } else if (-1 !== ['ssh', 'rfc4716'].indexOf(format)) {\n        format = 'ssh';\n      } else {\n        throw new Error(\"options.format must be 'spki', 'pkcs1', or 'ssh' for public RSA keys, not (\" + typeof format + ') ' + format);\n      }\n    } else {\n      // TODO test for all necessary keys (d, p, q ...)\n      if (!format || 'pkcs1' === format) {\n        format = 'pkcs1';\n      } else if ('pkcs8' !== format) {\n        throw new Error(\"options.format must be 'pkcs1' or 'pkcs8' for private RSA keys\");\n      }\n    }\n\n    if ('pkcs1' === format) {\n      if (jwk.d) {\n        return PEM.packBlock({\n          type: 'RSA PRIVATE KEY',\n          bytes: X509.packPkcs1(jwk)\n        });\n      } else {\n        return PEM.packBlock({\n          type: 'RSA PUBLIC KEY',\n          bytes: X509.packPkcs1(jwk)\n        });\n      }\n    } else if ('pkcs8' === format) {\n      return PEM.packBlock({\n        type: 'PRIVATE KEY',\n        bytes: X509.packPkcs8(jwk)\n      });\n    } else if (-1 !== ['spki', 'pkix'].indexOf(format)) {\n      return PEM.packBlock({\n        type: 'PUBLIC KEY',\n        bytes: X509.packSpki(jwk)\n      });\n    } else if (-1 !== ['ssh', 'rfc4716'].indexOf(format)) {\n      //return SSH.pack({ jwk: jwk, comment: opts.comment });\n      throw new Error('not supported yet');\n    } else {\n      throw new Error('Sanity Error: reached unreachable code block with format: ' + format);\n    }\n  });\n};\n\nnative.export = RSA.export;\n\nRSA.pack = function (opts) {\n  // wrapped in a promise for API compatibility\n  // with the forthcoming browser version\n  // (and potential future native node capability)\n  return Promise.resolve().then(function () {\n    return RSA.export(opts);\n  });\n};\n\nRSA._importSync = function (opts) {\n  if (!opts || !opts.pem || 'string' !== typeof opts.pem) {\n    throw new Error('must pass { pem: pem } as a string');\n  }\n\n  if (0 === opts.pem.indexOf('ssh-rsa ')) {\n    //return SSH.parse(opts.pem, jwk);\n    throw new Error('not supported, yet');\n  }\n\n  var pem = opts.pem;\n  var block = PEM.parseBlock(pem); //var hex = toHex(u8);\n\n  var jwk = X509._parseRsa(block.bytes);\n\n  if (opts.public) {\n    jwk = RSA.nueter(jwk);\n  }\n\n  return jwk;\n};\n\nRSA.parse = function parseRsa(opts) {\n  // wrapped in a promise for API compatibility\n  // with the forthcoming browser version\n  // (and potential future native node capability)\n  return Promise.resolve().then(function () {\n    return RSA._importSync(opts);\n  });\n};\n\nRSA.toJwk = RSA.import = RSA.parse;","map":{"version":3,"sources":["C:/Users/xuwen/Desktop/INFO340/project-2-xuwensi/node_modules/@root/keypairs/rsa.js"],"names":["RSA","module","exports","native","require","X509","PEM","sha2","Enc","_universal","_stance","generate","neuter","opts","jwk","Object","keys","forEach","k","indexOf","JSON","parse","stringify","__thumbprint","len","Math","floor","n","length","alg","sum","e","then","hash","bufToUrlBase64","Uint8Array","from","thumbprint","Promise","resolve","kty","import","export","Error","format","pub","public","p","d","packBlock","type","bytes","packPkcs1","packPkcs8","packSpki","pack","_importSync","pem","block","parseBlock","_parseRsa","nueter","parseRsa","toJwk"],"mappings":"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","sourcesContent":["/*global Promise*/\n'use strict';\n\nvar RSA = module.exports;\nvar native = require('./lib/node/rsa.js');\nvar X509 = require('@root/x509');\nvar PEM = require('@root/pem');\n//var SSH = require('./ssh-keys.js');\nvar sha2 = require('./lib/node/sha2.js');\nvar Enc = require('@root/encoding/base64');\n\nRSA._universal =\n\t'Bluecrypt only supports crypto with standard cross-browser and cross-platform support.';\nRSA._stance =\n\t\"We take the stance that if you're knowledgeable enough to\" +\n\t\" properly and securely use non-standard crypto then you shouldn't need Bluecrypt anyway.\";\nnative._stance = RSA._stance;\n\nRSA.generate = native.generate;\n\n// Chopping off the private parts is now part of the public API.\n// I thought it sounded a little too crude at first, but it really is the best name in every possible way.\nRSA.neuter = function(opts) {\n\t// trying to find the best balance of an immutable copy with custom attributes\n\tvar jwk = {};\n\tObject.keys(opts.jwk).forEach(function(k) {\n\t\tif ('undefined' === typeof opts.jwk[k]) {\n\t\t\treturn;\n\t\t}\n\t\t// ignore RSA private parts\n\t\tif (-1 !== ['d', 'p', 'q', 'dp', 'dq', 'qi'].indexOf(k)) {\n\t\t\treturn;\n\t\t}\n\t\tjwk[k] = JSON.parse(JSON.stringify(opts.jwk[k]));\n\t});\n\treturn jwk;\n};\nnative.neuter = RSA.neuter;\n\n// https://stackoverflow.com/questions/42588786/how-to-fingerprint-a-jwk\nRSA.__thumbprint = function(jwk) {\n\t// Use the same entropy for SHA as for key\n\tvar len = Math.floor(jwk.n.length * 0.75);\n\tvar alg = 'SHA-256';\n\t// TODO this may be a bug\n\t// need to confirm that the padding is no more or less than 1 byte\n\tif (len >= 511) {\n\t\talg = 'SHA-512';\n\t} else if (len >= 383) {\n\t\talg = 'SHA-384';\n\t}\n\treturn sha2\n\t\t.sum(alg, '{\"e\":\"' + jwk.e + '\",\"kty\":\"RSA\",\"n\":\"' + jwk.n + '\"}')\n\t\t.then(function(hash) {\n\t\t\treturn Enc.bufToUrlBase64(Uint8Array.from(hash));\n\t\t});\n};\n\nRSA.thumbprint = function(opts) {\n\treturn Promise.resolve().then(function() {\n\t\tvar jwk;\n\t\tif ('EC' === opts.kty) {\n\t\t\tjwk = opts;\n\t\t} else if (opts.jwk) {\n\t\t\tjwk = opts.jwk;\n\t\t} else {\n\t\t\treturn RSA.import(opts).then(function(jwk) {\n\t\t\t\treturn RSA.__thumbprint(jwk);\n\t\t\t});\n\t\t}\n\t\treturn RSA.__thumbprint(jwk);\n\t});\n};\n\nRSA.export = function(opts) {\n\treturn Promise.resolve().then(function() {\n\t\tif (!opts || !opts.jwk || 'object' !== typeof opts.jwk) {\n\t\t\tthrow new Error('must pass { jwk: jwk }');\n\t\t}\n\t\tvar jwk = JSON.parse(JSON.stringify(opts.jwk));\n\t\tvar format = opts.format;\n\t\tvar pub = opts.public;\n\t\tif (pub || -1 !== ['spki', 'pkix', 'ssh', 'rfc4716'].indexOf(format)) {\n\t\t\tjwk = RSA.neuter({ jwk: jwk });\n\t\t}\n\t\tif ('RSA' !== jwk.kty) {\n\t\t\tthrow new Error(\n\t\t\t\t\"options.jwk.kty must be 'RSA' for RSA keys: \" +\n\t\t\t\t\tJSON.stringify(jwk)\n\t\t\t);\n\t\t}\n\t\tif (!jwk.p) {\n\t\t\t// TODO test for n and e\n\t\t\tpub = true;\n\t\t\tif (!format || 'pkcs1' === format) {\n\t\t\t\tformat = 'pkcs1';\n\t\t\t} else if (-1 !== ['spki', 'pkix'].indexOf(format)) {\n\t\t\t\tformat = 'spki';\n\t\t\t} else if (-1 !== ['ssh', 'rfc4716'].indexOf(format)) {\n\t\t\t\tformat = 'ssh';\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"options.format must be 'spki', 'pkcs1', or 'ssh' for public RSA keys, not (\" +\n\t\t\t\t\t\ttypeof format +\n\t\t\t\t\t\t') ' +\n\t\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\t// TODO test for all necessary keys (d, p, q ...)\n\t\t\tif (!format || 'pkcs1' === format) {\n\t\t\t\tformat = 'pkcs1';\n\t\t\t} else if ('pkcs8' !== format) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"options.format must be 'pkcs1' or 'pkcs8' for private RSA keys\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif ('pkcs1' === format) {\n\t\t\tif (jwk.d) {\n\t\t\t\treturn PEM.packBlock({\n\t\t\t\t\ttype: 'RSA PRIVATE KEY',\n\t\t\t\t\tbytes: X509.packPkcs1(jwk)\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn PEM.packBlock({\n\t\t\t\t\ttype: 'RSA PUBLIC KEY',\n\t\t\t\t\tbytes: X509.packPkcs1(jwk)\n\t\t\t\t});\n\t\t\t}\n\t\t} else if ('pkcs8' === format) {\n\t\t\treturn PEM.packBlock({\n\t\t\t\ttype: 'PRIVATE KEY',\n\t\t\t\tbytes: X509.packPkcs8(jwk)\n\t\t\t});\n\t\t} else if (-1 !== ['spki', 'pkix'].indexOf(format)) {\n\t\t\treturn PEM.packBlock({\n\t\t\t\ttype: 'PUBLIC KEY',\n\t\t\t\tbytes: X509.packSpki(jwk)\n\t\t\t});\n\t\t} else if (-1 !== ['ssh', 'rfc4716'].indexOf(format)) {\n\t\t\t//return SSH.pack({ jwk: jwk, comment: opts.comment });\n\t\t\tthrow new Error('not supported yet');\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'Sanity Error: reached unreachable code block with format: ' +\n\t\t\t\t\tformat\n\t\t\t);\n\t\t}\n\t});\n};\nnative.export = RSA.export;\n\nRSA.pack = function(opts) {\n\t// wrapped in a promise for API compatibility\n\t// with the forthcoming browser version\n\t// (and potential future native node capability)\n\treturn Promise.resolve().then(function() {\n\t\treturn RSA.export(opts);\n\t});\n};\n\nRSA._importSync = function(opts) {\n\tif (!opts || !opts.pem || 'string' !== typeof opts.pem) {\n\t\tthrow new Error('must pass { pem: pem } as a string');\n\t}\n\n\tif (0 === opts.pem.indexOf('ssh-rsa ')) {\n\t\t//return SSH.parse(opts.pem, jwk);\n\t\tthrow new Error('not supported, yet');\n\t}\n\tvar pem = opts.pem;\n\tvar block = PEM.parseBlock(pem);\n\t//var hex = toHex(u8);\n\n\tvar jwk = X509._parseRsa(block.bytes);\n\n\tif (opts.public) {\n\t\tjwk = RSA.nueter(jwk);\n\t}\n\treturn jwk;\n};\nRSA.parse = function parseRsa(opts) {\n\t// wrapped in a promise for API compatibility\n\t// with the forthcoming browser version\n\t// (and potential future native node capability)\n\treturn Promise.resolve().then(function() {\n\t\treturn RSA._importSync(opts);\n\t});\n};\nRSA.toJwk = RSA.import = RSA.parse;\n"]},"metadata":{},"sourceType":"script"}