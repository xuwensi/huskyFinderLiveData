{"ast":null,"code":"// Copyright 2018 AJ ONeal. All rights reserved\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n'use strict';\n\nvar ASN1 = module.exports;\n\nvar Enc = require('@root/encoding/hex'); //\n// Parser\n//\n// Although I've only seen 9 max in https certificates themselves,\n// but each domain list could have up to 100\n\n\nASN1.ELOOPN = 102;\nASN1.ELOOP = 'uASN1.js Error: iterated over ' + ASN1.ELOOPN + '+ elements (probably a malformed file)'; // I've seen https certificates go 29 deep\n\nASN1.EDEEPN = 60;\nASN1.EDEEP = 'uASN1.js Error: element nested ' + ASN1.EDEEPN + '+ layers deep (probably a malformed file)'; // Container Types are Sequence 0x30, Container Array? (0xA0, 0xA1)\n// Value Types are Boolean 0x01, Integer 0x02, Null 0x05, Object ID 0x06, String 0x0C, 0x16, 0x13, 0x1e Value Array? (0x82)\n// Bit String (0x03) and Octet String (0x04) may be values or containers\n// Sometimes Bit String is used as a container (RSA Pub Spki)\n\nASN1.CTYPES = [0x30, 0x31, 0xa0, 0xa1];\nASN1.VTYPES = [0x01, 0x02, 0x05, 0x06, 0x0c, 0x82];\n\nASN1.parseVerbose = function parseAsn1Helper(buf, opts) {\n  if (!opts) {\n    opts = {};\n  } //var ws = '  ';\n\n\n  function parseAsn1(buf, depth, eager) {\n    if (depth.length >= ASN1.EDEEPN) {\n      throw new Error(ASN1.EDEEP);\n    }\n\n    var index = 2; // we know, at minimum, data starts after type (0) and lengthSize (1)\n\n    var asn1 = {\n      type: buf[0],\n      lengthSize: 0,\n      length: buf[1]\n    };\n    var child;\n    var iters = 0;\n    var adjust = 0;\n    var adjustedLen; // Determine how many bytes the length uses, and what it is\n\n    if (0x80 & asn1.length) {\n      asn1.lengthSize = 0x7f & asn1.length; // I think that buf->hex->int solves the problem of Endianness... not sure\n\n      asn1.length = parseInt(Enc.bufToHex(buf.slice(index, index + asn1.lengthSize)), 16);\n      index += asn1.lengthSize;\n    } // High-order bit Integers have a leading 0x00 to signify that they are positive.\n    // Bit Streams use the first byte to signify padding, which x.509 doesn't use.\n\n\n    if (0x00 === buf[index] && (0x02 === asn1.type || 0x03 === asn1.type)) {\n      // However, 0x00 on its own is a valid number\n      if (asn1.length > 1) {\n        index += 1;\n        adjust = -1;\n      }\n    }\n\n    adjustedLen = asn1.length + adjust; //console.warn(depth.join(ws) + '0x' + Enc.numToHex(asn1.type), index, 'len:', asn1.length, asn1);\n\n    function parseChildren(eager) {\n      asn1.children = []; //console.warn('1 len:', (2 + asn1.lengthSize + asn1.length), 'idx:', index, 'clen:', 0);\n\n      while (iters < ASN1.ELOOPN && index < 2 + asn1.length + asn1.lengthSize) {\n        iters += 1;\n        depth.length += 1;\n        child = parseAsn1(buf.slice(index, index + adjustedLen), depth, eager);\n        depth.length -= 1; // The numbers don't match up exactly and I don't remember why...\n        // probably something with adjustedLen or some such, but the tests pass\n\n        index += 2 + child.lengthSize + child.length; //console.warn('2 len:', (2 + asn1.lengthSize + asn1.length), 'idx:', index, 'clen:', (2 + child.lengthSize + child.length));\n\n        if (index > 2 + asn1.lengthSize + asn1.length) {\n          if (!eager) {\n            console.error(JSON.stringify(asn1, ASN1._replacer, 2));\n          }\n\n          throw new Error('Parse error: child value length (' + child.length + ') is greater than remaining parent length (' + (asn1.length - index) + ' = ' + asn1.length + ' - ' + index + ')');\n        }\n\n        asn1.children.push(child); //console.warn(depth.join(ws) + '0x' + Enc.numToHex(asn1.type), index, 'len:', asn1.length, asn1);\n      }\n\n      if (index !== 2 + asn1.lengthSize + asn1.length) {\n        //console.warn('index:', index, 'length:', (2 + asn1.lengthSize + asn1.length));\n        throw new Error('premature end-of-file');\n      }\n\n      if (iters >= ASN1.ELOOPN) {\n        throw new Error(ASN1.ELOOP);\n      }\n\n      delete asn1.value;\n      return asn1;\n    } // Recurse into types that are _always_ containers\n\n\n    if (-1 !== ASN1.CTYPES.indexOf(asn1.type)) {\n      return parseChildren(eager);\n    } // Return types that are _always_ values\n\n\n    asn1.value = buf.slice(index, index + adjustedLen);\n\n    if (opts.json) {\n      asn1.value = Enc.bufToHex(asn1.value);\n    }\n\n    if (-1 !== ASN1.VTYPES.indexOf(asn1.type)) {\n      return asn1;\n    } // For ambigious / unknown types, recurse and return on failure\n    // (and return child array size to zero)\n\n\n    try {\n      return parseChildren(true);\n    } catch (e) {\n      asn1.children.length = 0;\n      return asn1;\n    }\n  }\n\n  var asn1 = parseAsn1(buf, []);\n  var len = buf.byteLength || buf.length;\n\n  if (len !== 2 + asn1.lengthSize + asn1.length) {\n    throw new Error('Length of buffer does not match length of ASN.1 sequence.');\n  }\n\n  return asn1;\n};\n\nASN1._toArray = function toArray(next, opts) {\n  var typ = opts.json ? Enc.numToHex(next.type) : next.type;\n  var val = next.value;\n\n  if (val) {\n    if ('string' !== typeof val && opts.json) {\n      val = Enc.bufToHex(val);\n    }\n\n    return [typ, val];\n  }\n\n  return [typ, next.children.map(function (child) {\n    return toArray(child, opts);\n  })];\n};\n\nASN1.parse = function (opts) {\n  var opts2 = {\n    json: false !== opts.json\n  };\n  var verbose = ASN1.parseVerbose(opts.der, opts2);\n\n  if (opts.verbose) {\n    return verbose;\n  }\n\n  return ASN1._toArray(verbose, opts2);\n};\n\nASN1._replacer = function (k, v) {\n  if ('type' === k) {\n    return '0x' + Enc.numToHex(v);\n  }\n\n  if (v && 'value' === k) {\n    return '0x' + Enc.bufToHex(v.data || v);\n  }\n\n  return v;\n};","map":{"version":3,"sources":["C:/Users/xuwen/Desktop/INFO340/project-2-xuwensi/node_modules/@root/asn1/parser.js"],"names":["ASN1","module","exports","Enc","require","ELOOPN","ELOOP","EDEEPN","EDEEP","CTYPES","VTYPES","parseVerbose","parseAsn1Helper","buf","opts","parseAsn1","depth","eager","length","Error","index","asn1","type","lengthSize","child","iters","adjust","adjustedLen","parseInt","bufToHex","slice","parseChildren","children","console","error","JSON","stringify","_replacer","push","value","indexOf","json","e","len","byteLength","_toArray","toArray","next","typ","numToHex","val","map","parse","opts2","verbose","der","k","v","data"],"mappings":"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","sourcesContent":["// Copyright 2018 AJ ONeal. All rights reserved\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n'use strict';\n\nvar ASN1 = module.exports;\nvar Enc = require('@root/encoding/hex');\n\n//\n// Parser\n//\n\n// Although I've only seen 9 max in https certificates themselves,\n// but each domain list could have up to 100\nASN1.ELOOPN = 102;\nASN1.ELOOP =\n\t'uASN1.js Error: iterated over ' +\n\tASN1.ELOOPN +\n\t'+ elements (probably a malformed file)';\n// I've seen https certificates go 29 deep\nASN1.EDEEPN = 60;\nASN1.EDEEP =\n\t'uASN1.js Error: element nested ' +\n\tASN1.EDEEPN +\n\t'+ layers deep (probably a malformed file)';\n// Container Types are Sequence 0x30, Container Array? (0xA0, 0xA1)\n// Value Types are Boolean 0x01, Integer 0x02, Null 0x05, Object ID 0x06, String 0x0C, 0x16, 0x13, 0x1e Value Array? (0x82)\n// Bit String (0x03) and Octet String (0x04) may be values or containers\n// Sometimes Bit String is used as a container (RSA Pub Spki)\nASN1.CTYPES = [0x30, 0x31, 0xa0, 0xa1];\nASN1.VTYPES = [0x01, 0x02, 0x05, 0x06, 0x0c, 0x82];\nASN1.parseVerbose = function parseAsn1Helper(buf, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\t//var ws = '  ';\n\tfunction parseAsn1(buf, depth, eager) {\n\t\tif (depth.length >= ASN1.EDEEPN) {\n\t\t\tthrow new Error(ASN1.EDEEP);\n\t\t}\n\n\t\tvar index = 2; // we know, at minimum, data starts after type (0) and lengthSize (1)\n\t\tvar asn1 = { type: buf[0], lengthSize: 0, length: buf[1] };\n\t\tvar child;\n\t\tvar iters = 0;\n\t\tvar adjust = 0;\n\t\tvar adjustedLen;\n\n\t\t// Determine how many bytes the length uses, and what it is\n\t\tif (0x80 & asn1.length) {\n\t\t\tasn1.lengthSize = 0x7f & asn1.length;\n\t\t\t// I think that buf->hex->int solves the problem of Endianness... not sure\n\t\t\tasn1.length = parseInt(\n\t\t\t\tEnc.bufToHex(buf.slice(index, index + asn1.lengthSize)),\n\t\t\t\t16\n\t\t\t);\n\t\t\tindex += asn1.lengthSize;\n\t\t}\n\n\t\t// High-order bit Integers have a leading 0x00 to signify that they are positive.\n\t\t// Bit Streams use the first byte to signify padding, which x.509 doesn't use.\n\t\tif (0x00 === buf[index] && (0x02 === asn1.type || 0x03 === asn1.type)) {\n\t\t\t// However, 0x00 on its own is a valid number\n\t\t\tif (asn1.length > 1) {\n\t\t\t\tindex += 1;\n\t\t\t\tadjust = -1;\n\t\t\t}\n\t\t}\n\t\tadjustedLen = asn1.length + adjust;\n\n\t\t//console.warn(depth.join(ws) + '0x' + Enc.numToHex(asn1.type), index, 'len:', asn1.length, asn1);\n\n\t\tfunction parseChildren(eager) {\n\t\t\tasn1.children = [];\n\t\t\t//console.warn('1 len:', (2 + asn1.lengthSize + asn1.length), 'idx:', index, 'clen:', 0);\n\t\t\twhile (\n\t\t\t\titers < ASN1.ELOOPN &&\n\t\t\t\tindex < 2 + asn1.length + asn1.lengthSize\n\t\t\t) {\n\t\t\t\titers += 1;\n\t\t\t\tdepth.length += 1;\n\t\t\t\tchild = parseAsn1(\n\t\t\t\t\tbuf.slice(index, index + adjustedLen),\n\t\t\t\t\tdepth,\n\t\t\t\t\teager\n\t\t\t\t);\n\t\t\t\tdepth.length -= 1;\n\t\t\t\t// The numbers don't match up exactly and I don't remember why...\n\t\t\t\t// probably something with adjustedLen or some such, but the tests pass\n\t\t\t\tindex += 2 + child.lengthSize + child.length;\n\t\t\t\t//console.warn('2 len:', (2 + asn1.lengthSize + asn1.length), 'idx:', index, 'clen:', (2 + child.lengthSize + child.length));\n\t\t\t\tif (index > 2 + asn1.lengthSize + asn1.length) {\n\t\t\t\t\tif (!eager) {\n\t\t\t\t\t\tconsole.error(JSON.stringify(asn1, ASN1._replacer, 2));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Parse error: child value length (' +\n\t\t\t\t\t\t\tchild.length +\n\t\t\t\t\t\t\t') is greater than remaining parent length (' +\n\t\t\t\t\t\t\t(asn1.length - index) +\n\t\t\t\t\t\t\t' = ' +\n\t\t\t\t\t\t\tasn1.length +\n\t\t\t\t\t\t\t' - ' +\n\t\t\t\t\t\t\tindex +\n\t\t\t\t\t\t\t')'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tasn1.children.push(child);\n\t\t\t\t//console.warn(depth.join(ws) + '0x' + Enc.numToHex(asn1.type), index, 'len:', asn1.length, asn1);\n\t\t\t}\n\t\t\tif (index !== 2 + asn1.lengthSize + asn1.length) {\n\t\t\t\t//console.warn('index:', index, 'length:', (2 + asn1.lengthSize + asn1.length));\n\t\t\t\tthrow new Error('premature end-of-file');\n\t\t\t}\n\t\t\tif (iters >= ASN1.ELOOPN) {\n\t\t\t\tthrow new Error(ASN1.ELOOP);\n\t\t\t}\n\n\t\t\tdelete asn1.value;\n\t\t\treturn asn1;\n\t\t}\n\n\t\t// Recurse into types that are _always_ containers\n\t\tif (-1 !== ASN1.CTYPES.indexOf(asn1.type)) {\n\t\t\treturn parseChildren(eager);\n\t\t}\n\n\t\t// Return types that are _always_ values\n\t\tasn1.value = buf.slice(index, index + adjustedLen);\n\t\tif (opts.json) {\n\t\t\tasn1.value = Enc.bufToHex(asn1.value);\n\t\t}\n\t\tif (-1 !== ASN1.VTYPES.indexOf(asn1.type)) {\n\t\t\treturn asn1;\n\t\t}\n\n\t\t// For ambigious / unknown types, recurse and return on failure\n\t\t// (and return child array size to zero)\n\t\ttry {\n\t\t\treturn parseChildren(true);\n\t\t} catch (e) {\n\t\t\tasn1.children.length = 0;\n\t\t\treturn asn1;\n\t\t}\n\t}\n\n\tvar asn1 = parseAsn1(buf, []);\n\tvar len = buf.byteLength || buf.length;\n\tif (len !== 2 + asn1.lengthSize + asn1.length) {\n\t\tthrow new Error(\n\t\t\t'Length of buffer does not match length of ASN.1 sequence.'\n\t\t);\n\t}\n\treturn asn1;\n};\nASN1._toArray = function toArray(next, opts) {\n\tvar typ = opts.json ? Enc.numToHex(next.type) : next.type;\n\tvar val = next.value;\n\tif (val) {\n\t\tif ('string' !== typeof val && opts.json) {\n\t\t\tval = Enc.bufToHex(val);\n\t\t}\n\t\treturn [typ, val];\n\t}\n\treturn [\n\t\ttyp,\n\t\tnext.children.map(function(child) {\n\t\t\treturn toArray(child, opts);\n\t\t})\n\t];\n};\nASN1.parse = function(opts) {\n\tvar opts2 = { json: false !== opts.json };\n\tvar verbose = ASN1.parseVerbose(opts.der, opts2);\n\tif (opts.verbose) {\n\t\treturn verbose;\n\t}\n\treturn ASN1._toArray(verbose, opts2);\n};\nASN1._replacer = function(k, v) {\n\tif ('type' === k) {\n\t\treturn '0x' + Enc.numToHex(v);\n\t}\n\tif (v && 'value' === k) {\n\t\treturn '0x' + Enc.bufToHex(v.data || v);\n\t}\n\treturn v;\n};\n"]},"metadata":{},"sourceType":"script"}