{"ast":null,"code":"/*global Promise*/\n'use strict';\n\nrequire('@root/encoding/bytes');\n\nvar Enc = require('@root/encoding/base64');\n\nvar Keypairs = module.exports;\n\nvar Rasha = require('./rsa.js');\n\nvar Eckles = require('./ecdsa.js');\n\nvar native = require('./lib/node/keypairs.js');\n\nKeypairs.parse = function (opts) {\n  opts = opts || {};\n  var err;\n  var jwk;\n  var pem;\n  var p;\n\n  if (!opts.key || !opts.key.kty) {\n    try {\n      jwk = JSON.parse(opts.key);\n      p = Keypairs.export({\n        jwk: jwk\n      }).catch(function (e) {\n        pem = opts.key;\n        err = new Error(\"Not a valid jwk '\" + JSON.stringify(jwk) + \"':\" + e.message);\n        err.code = 'EINVALID';\n        return Promise.reject(err);\n      }).then(function () {\n        return jwk;\n      });\n    } catch (e) {\n      p = Keypairs.import({\n        pem: opts.key\n      }).catch(function (e) {\n        err = new Error('Could not parse key (type ' + typeof opts.key + \") '\" + opts.key + \"': \" + e.message);\n        err.code = 'EPARSE';\n        return Promise.reject(err);\n      });\n    }\n  } else {\n    p = Promise.resolve(opts.key);\n  }\n\n  return p.then(function (jwk) {\n    var pubopts = JSON.parse(JSON.stringify(opts));\n    pubopts.jwk = jwk;\n    return Keypairs.publish(pubopts).then(function (pub) {\n      // 'd' happens to be the name of a private part of both RSA and ECDSA keys\n      if (opts.public || opts.publish || !jwk.d) {\n        if (opts.private) {\n          // TODO test that it can actually sign?\n          err = new Error(\"Not a private key '\" + JSON.stringify(jwk) + \"'\");\n          err.code = 'ENOTPRIVATE';\n          return Promise.reject(err);\n        }\n\n        return {\n          public: pub\n        };\n      } else {\n        return {\n          private: jwk,\n          public: pub\n        };\n      }\n    });\n  });\n};\n\nKeypairs.parseOrGenerate = function (opts) {\n  if (!opts.key) {\n    return Keypairs.generate(opts);\n  }\n\n  opts.private = true;\n  return Keypairs.parse(opts).catch(function (e) {\n    return Keypairs.generate(opts).then(function (pair) {\n      pair.parseError = e;\n      return pair;\n    });\n  });\n};\n\nKeypairs._stance = \"We take the stance that if you're knowledgeable enough to\" + \" properly and securely use non-standard crypto then you shouldn't need Bluecrypt anyway.\";\nKeypairs._universal = 'Bluecrypt only supports crypto with standard cross-browser and cross-platform support.';\n\nKeypairs.generate = function (opts) {\n  opts = opts || {};\n  var p;\n\n  if (!opts.kty) {\n    opts.kty = opts.type;\n  }\n\n  if (!opts.kty) {\n    opts.kty = 'EC';\n  }\n\n  if (/^EC/i.test(opts.kty)) {\n    p = Eckles.generate(opts);\n  } else if (/^RSA$/i.test(opts.kty)) {\n    p = Rasha.generate(opts);\n  } else {\n    return Promise.Reject(new Error(\"'\" + opts.kty + \"' is not a well-supported key type.\" + Keypairs._universal + \" Please choose 'EC', or 'RSA' if you have good reason to.\"));\n  }\n\n  return p.then(function (pair) {\n    return Keypairs.thumbprint({\n      jwk: pair.public\n    }).then(function (thumb) {\n      pair.private.kid = thumb; // maybe not the same id on the private key?\n\n      pair.public.kid = thumb;\n      return pair;\n    });\n  });\n};\n\nKeypairs.import = function (opts) {\n  return Eckles.import(opts).catch(function () {\n    return Rasha.import(opts);\n  }).then(function (jwk) {\n    return Keypairs.thumbprint({\n      jwk: jwk\n    }).then(function (thumb) {\n      jwk.kid = thumb;\n      return jwk;\n    });\n  });\n};\n\nKeypairs.export = function (opts) {\n  return Eckles.export(opts).catch(function (err) {\n    return Rasha.export(opts).catch(function () {\n      return Promise.reject(err);\n    });\n  });\n}; // XXX\n\n\nnative.export = Keypairs.export;\n/**\n * Chopping off the private parts is now part of the public API.\n * I thought it sounded a little too crude at first, but it really is the best name in every possible way.\n */\n\nKeypairs.neuter = function (opts) {\n  /** trying to find the best balance of an immutable copy with custom attributes */\n  var jwk = {};\n  Object.keys(opts.jwk).forEach(function (k) {\n    if ('undefined' === typeof opts.jwk[k]) {\n      return;\n    } // ignore RSA and EC private parts\n\n\n    if (-1 !== ['d', 'p', 'q', 'dp', 'dq', 'qi'].indexOf(k)) {\n      return;\n    }\n\n    jwk[k] = JSON.parse(JSON.stringify(opts.jwk[k]));\n  });\n  return jwk;\n};\n\nKeypairs.thumbprint = function (opts) {\n  return Promise.resolve().then(function () {\n    if (/EC/i.test(opts.jwk.kty)) {\n      return Eckles.thumbprint(opts);\n    } else {\n      return Rasha.thumbprint(opts);\n    }\n  });\n};\n\nKeypairs.publish = function (opts) {\n  if ('object' !== typeof opts.jwk || !opts.jwk.kty) {\n    throw new Error('invalid jwk: ' + JSON.stringify(opts.jwk));\n  }\n  /** returns a copy */\n\n\n  var jwk = Keypairs.neuter(opts);\n\n  if (jwk.exp) {\n    jwk.exp = setTime(jwk.exp);\n  } else {\n    if (opts.exp) {\n      jwk.exp = setTime(opts.exp);\n    } else if (opts.expiresIn) {\n      jwk.exp = Math.round(Date.now() / 1000) + opts.expiresIn;\n    } else if (opts.expiresAt) {\n      jwk.exp = opts.expiresAt;\n    }\n  }\n\n  if (!jwk.use && false !== jwk.use) {\n    jwk.use = 'sig';\n  }\n\n  if (jwk.kid) {\n    return Promise.resolve(jwk);\n  }\n\n  return Keypairs.thumbprint({\n    jwk: jwk\n  }).then(function (thumb) {\n    jwk.kid = thumb;\n    return jwk;\n  });\n}; // JWT a.k.a. JWS with Claims using Compact Serialization\n\n\nKeypairs.signJwt = function (opts) {\n  return Keypairs.thumbprint({\n    jwk: opts.jwk\n  }).then(function (thumb) {\n    var header = opts.header || {};\n    var claims = JSON.parse(JSON.stringify(opts.claims || {}));\n    header.typ = 'JWT';\n\n    if (!header.kid && false !== header.kid) {\n      header.kid = thumb;\n    }\n\n    if (!header.alg && opts.alg) {\n      header.alg = opts.alg;\n    }\n\n    if (!claims.iat && (false === claims.iat || false === opts.iat)) {\n      claims.iat = undefined;\n    } else if (!claims.iat) {\n      claims.iat = Math.round(Date.now() / 1000);\n    }\n\n    if (opts.exp) {\n      claims.exp = setTime(opts.exp);\n    } else if (!claims.exp && (false === claims.exp || false === opts.exp)) {\n      claims.exp = undefined;\n    } else if (!claims.exp) {\n      throw new Error(\"opts.claims.exp should be the expiration date as seconds, human form (i.e. '1h' or '15m') or false\");\n    }\n\n    if (opts.iss) {\n      claims.iss = opts.iss;\n    }\n\n    if (!claims.iss && (false === claims.iss || false === opts.iss)) {\n      claims.iss = undefined;\n    } else if (!claims.iss) {\n      throw new Error('opts.claims.iss should be in the form of https://example.com/, a secure OIDC base url');\n    }\n\n    return Keypairs.signJws({\n      jwk: opts.jwk,\n      pem: opts.pem,\n      protected: header,\n      header: undefined,\n      payload: claims\n    }).then(function (jws) {\n      return [jws.protected, jws.payload, jws.signature].join('.');\n    });\n  });\n};\n\nKeypairs.signJws = function (opts) {\n  return Keypairs.thumbprint(opts).then(function (thumb) {\n    function alg() {\n      if (!opts.jwk) {\n        throw new Error(\"opts.jwk must exist and must declare 'typ'\");\n      }\n\n      if (opts.jwk.alg) {\n        return opts.jwk.alg;\n      }\n\n      var typ = 'RSA' === opts.jwk.kty ? 'RS' : 'ES';\n      return typ + Keypairs._getBits(opts);\n    }\n\n    function sign() {\n      var protect = opts.protected;\n      var payload = opts.payload; // Compute JWS signature\n\n      var protectedHeader = ''; // Because unprotected headers are allowed, regrettably...\n      // https://stackoverflow.com/a/46288694\n\n      if (false !== protect) {\n        if (!protect) {\n          protect = {};\n        }\n\n        if (!protect.alg) {\n          protect.alg = alg();\n        } // There's a particular request where ACME / Let's Encrypt explicitly doesn't use a kid\n\n\n        if (false === protect.kid) {\n          protect.kid = undefined;\n        } else if (!protect.kid) {\n          protect.kid = thumb;\n        }\n\n        protectedHeader = JSON.stringify(protect);\n      } // Not sure how to handle the empty case since ACME POST-as-GET must be empty\n      //if (!payload) {\n      //  throw new Error(\"opts.payload should be JSON, string, or ArrayBuffer (it may be empty, but that must be explicit)\");\n      //}\n      // Trying to detect if it's a plain object (not Buffer, ArrayBuffer, Array, Uint8Array, etc)\n\n\n      if (payload && 'string' !== typeof payload && 'undefined' === typeof payload.byteLength && 'undefined' === typeof payload.buffer) {\n        payload = JSON.stringify(payload);\n      } // Converting to a buffer, even if it was just converted to a string\n\n\n      if ('string' === typeof payload) {\n        payload = Enc.strToBuf(payload);\n      }\n\n      var protected64 = Enc.strToUrlBase64(protectedHeader);\n      var payload64 = Enc.bufToUrlBase64(payload);\n      var msg = protected64 + '.' + payload64;\n      return native._sign(opts, msg).then(function (buf) {\n        var signedMsg = {\n          protected: protected64,\n          payload: payload64,\n          signature: Enc.bufToUrlBase64(buf)\n        };\n        return signedMsg;\n      });\n    }\n\n    if (opts.jwk) {\n      return sign();\n    } else {\n      return Keypairs.import({\n        pem: opts.pem\n      }).then(function (pair) {\n        opts.jwk = pair.private;\n        return sign();\n      });\n    }\n  });\n}; // TODO expose consistently\n\n\nKeypairs.sign = native._sign;\n\nKeypairs._getBits = function (opts) {\n  if (opts.alg) {\n    return opts.alg.replace(/[a-z\\-]/gi, '');\n  }\n\n  if (opts.protected && opts.protected.alg) {\n    return opts.protected.alg.replace(/[a-z\\-]/gi, '');\n  } // base64 len to byte len\n\n\n  var len = Math.floor((opts.jwk.n || '').length * 0.75); // TODO this may be a bug\n  // need to confirm that the padding is no more or less than 1 byte\n\n  if (/521/.test(opts.jwk.crv) || len >= 511) {\n    return '512';\n  } else if (/384/.test(opts.jwk.crv) || len >= 383) {\n    return '384';\n  }\n\n  return '256';\n}; // XXX\n\n\nnative._getBits = Keypairs._getBits;\n\nfunction setTime(time) {\n  if ('number' === typeof time) {\n    return time;\n  }\n\n  var t = time.match(/^(\\-?\\d+)([dhms])$/i);\n\n  if (!t || !t[0]) {\n    throw new Error(\"'\" + time + \"' should be datetime in seconds or human-readable format (i.e. 3d, 1h, 15m, 30s\");\n  }\n\n  var now = Math.round(Date.now() / 1000);\n  var num = parseInt(t[1], 10);\n  var unit = t[2];\n  var mult = 1;\n\n  switch (unit) {\n    // fancy fallthrough, what fun!\n    case 'd':\n      mult *= 24;\n\n    /*falls through*/\n\n    case 'h':\n      mult *= 60;\n\n    /*falls through*/\n\n    case 'm':\n      mult *= 60;\n\n    /*falls through*/\n\n    case 's':\n      mult *= 1;\n  }\n\n  return now + mult * num;\n}","map":{"version":3,"sources":["C:/Users/xuwen/Desktop/INFO340/project-2-xuwensi/node_modules/@root/keypairs/keypairs.js"],"names":["require","Enc","Keypairs","module","exports","Rasha","Eckles","native","parse","opts","err","jwk","pem","p","key","kty","JSON","export","catch","e","Error","stringify","message","code","Promise","reject","then","import","resolve","pubopts","publish","pub","public","d","private","parseOrGenerate","generate","pair","parseError","_stance","_universal","type","test","Reject","thumbprint","thumb","kid","neuter","Object","keys","forEach","k","indexOf","exp","setTime","expiresIn","Math","round","Date","now","expiresAt","use","signJwt","header","claims","typ","alg","iat","undefined","iss","signJws","protected","payload","jws","signature","join","_getBits","sign","protect","protectedHeader","byteLength","buffer","strToBuf","protected64","strToUrlBase64","payload64","bufToUrlBase64","msg","_sign","buf","signedMsg","replace","len","floor","n","length","crv","time","t","match","num","parseInt","unit","mult"],"mappings":"AAAA;AACA;;AAEAA,OAAO,CAAC,sBAAD,CAAP;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,uBAAD,CAAjB;;AAEA,IAAIE,QAAQ,GAAGC,MAAM,CAACC,OAAtB;;AACA,IAAIC,KAAK,GAAGL,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAIM,MAAM,GAAGN,OAAO,CAAC,YAAD,CAApB;;AACA,IAAIO,MAAM,GAAGP,OAAO,CAAC,wBAAD,CAApB;;AAEAE,QAAQ,CAACM,KAAT,GAAiB,UAASC,IAAT,EAAe;AAC/BA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AAEA,MAAIC,GAAJ;AACA,MAAIC,GAAJ;AACA,MAAIC,GAAJ;AACA,MAAIC,CAAJ;;AAEA,MAAI,CAACJ,IAAI,CAACK,GAAN,IAAa,CAACL,IAAI,CAACK,GAAL,CAASC,GAA3B,EAAgC;AAC/B,QAAI;AACHJ,MAAAA,GAAG,GAAGK,IAAI,CAACR,KAAL,CAAWC,IAAI,CAACK,GAAhB,CAAN;AACAD,MAAAA,CAAC,GAAGX,QAAQ,CAACe,MAAT,CAAgB;AAAEN,QAAAA,GAAG,EAAEA;AAAP,OAAhB,EACFO,KADE,CACI,UAASC,CAAT,EAAY;AAClBP,QAAAA,GAAG,GAAGH,IAAI,CAACK,GAAX;AACAJ,QAAAA,GAAG,GAAG,IAAIU,KAAJ,CACL,sBACCJ,IAAI,CAACK,SAAL,CAAeV,GAAf,CADD,GAEC,IAFD,GAGCQ,CAAC,CAACG,OAJE,CAAN;AAMAZ,QAAAA,GAAG,CAACa,IAAJ,GAAW,UAAX;AACA,eAAOC,OAAO,CAACC,MAAR,CAAef,GAAf,CAAP;AACA,OAXE,EAYFgB,IAZE,CAYG,YAAW;AAChB,eAAOf,GAAP;AACA,OAdE,CAAJ;AAeA,KAjBD,CAiBE,OAAOQ,CAAP,EAAU;AACXN,MAAAA,CAAC,GAAGX,QAAQ,CAACyB,MAAT,CAAgB;AAAEf,QAAAA,GAAG,EAAEH,IAAI,CAACK;AAAZ,OAAhB,EAAmCI,KAAnC,CAAyC,UAASC,CAAT,EAAY;AACxDT,QAAAA,GAAG,GAAG,IAAIU,KAAJ,CACL,+BACC,OAAOX,IAAI,CAACK,GADb,GAEC,KAFD,GAGCL,IAAI,CAACK,GAHN,GAIC,KAJD,GAKCK,CAAC,CAACG,OANE,CAAN;AAQAZ,QAAAA,GAAG,CAACa,IAAJ,GAAW,QAAX;AACA,eAAOC,OAAO,CAACC,MAAR,CAAef,GAAf,CAAP;AACA,OAXG,CAAJ;AAYA;AACD,GAhCD,MAgCO;AACNG,IAAAA,CAAC,GAAGW,OAAO,CAACI,OAAR,CAAgBnB,IAAI,CAACK,GAArB,CAAJ;AACA;;AAED,SAAOD,CAAC,CAACa,IAAF,CAAO,UAASf,GAAT,EAAc;AAC3B,QAAIkB,OAAO,GAAGb,IAAI,CAACR,KAAL,CAAWQ,IAAI,CAACK,SAAL,CAAeZ,IAAf,CAAX,CAAd;AACAoB,IAAAA,OAAO,CAAClB,GAAR,GAAcA,GAAd;AACA,WAAOT,QAAQ,CAAC4B,OAAT,CAAiBD,OAAjB,EAA0BH,IAA1B,CAA+B,UAASK,GAAT,EAAc;AACnD;AACA,UAAItB,IAAI,CAACuB,MAAL,IAAevB,IAAI,CAACqB,OAApB,IAA+B,CAACnB,GAAG,CAACsB,CAAxC,EAA2C;AAC1C,YAAIxB,IAAI,CAACyB,OAAT,EAAkB;AACjB;AACAxB,UAAAA,GAAG,GAAG,IAAIU,KAAJ,CACL,wBAAwBJ,IAAI,CAACK,SAAL,CAAeV,GAAf,CAAxB,GAA8C,GADzC,CAAN;AAGAD,UAAAA,GAAG,CAACa,IAAJ,GAAW,aAAX;AACA,iBAAOC,OAAO,CAACC,MAAR,CAAef,GAAf,CAAP;AACA;;AACD,eAAO;AAAEsB,UAAAA,MAAM,EAAED;AAAV,SAAP;AACA,OAVD,MAUO;AACN,eAAO;AAAEG,UAAAA,OAAO,EAAEvB,GAAX;AAAgBqB,UAAAA,MAAM,EAAED;AAAxB,SAAP;AACA;AACD,KAfM,CAAP;AAgBA,GAnBM,CAAP;AAoBA,CAhED;;AAkEA7B,QAAQ,CAACiC,eAAT,GAA2B,UAAS1B,IAAT,EAAe;AACzC,MAAI,CAACA,IAAI,CAACK,GAAV,EAAe;AACd,WAAOZ,QAAQ,CAACkC,QAAT,CAAkB3B,IAAlB,CAAP;AACA;;AACDA,EAAAA,IAAI,CAACyB,OAAL,GAAe,IAAf;AACA,SAAOhC,QAAQ,CAACM,KAAT,CAAeC,IAAf,EAAqBS,KAArB,CAA2B,UAASC,CAAT,EAAY;AAC7C,WAAOjB,QAAQ,CAACkC,QAAT,CAAkB3B,IAAlB,EAAwBiB,IAAxB,CAA6B,UAASW,IAAT,EAAe;AAClDA,MAAAA,IAAI,CAACC,UAAL,GAAkBnB,CAAlB;AACA,aAAOkB,IAAP;AACA,KAHM,CAAP;AAIA,GALM,CAAP;AAMA,CAXD;;AAaAnC,QAAQ,CAACqC,OAAT,GACC,8DACA,0FAFD;AAGArC,QAAQ,CAACsC,UAAT,GACC,wFADD;;AAEAtC,QAAQ,CAACkC,QAAT,GAAoB,UAAS3B,IAAT,EAAe;AAClCA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,MAAII,CAAJ;;AACA,MAAI,CAACJ,IAAI,CAACM,GAAV,EAAe;AACdN,IAAAA,IAAI,CAACM,GAAL,GAAWN,IAAI,CAACgC,IAAhB;AACA;;AACD,MAAI,CAAChC,IAAI,CAACM,GAAV,EAAe;AACdN,IAAAA,IAAI,CAACM,GAAL,GAAW,IAAX;AACA;;AACD,MAAI,OAAO2B,IAAP,CAAYjC,IAAI,CAACM,GAAjB,CAAJ,EAA2B;AAC1BF,IAAAA,CAAC,GAAGP,MAAM,CAAC8B,QAAP,CAAgB3B,IAAhB,CAAJ;AACA,GAFD,MAEO,IAAI,SAASiC,IAAT,CAAcjC,IAAI,CAACM,GAAnB,CAAJ,EAA6B;AACnCF,IAAAA,CAAC,GAAGR,KAAK,CAAC+B,QAAN,CAAe3B,IAAf,CAAJ;AACA,GAFM,MAEA;AACN,WAAOe,OAAO,CAACmB,MAAR,CACN,IAAIvB,KAAJ,CACC,MACCX,IAAI,CAACM,GADN,GAEC,qCAFD,GAGCb,QAAQ,CAACsC,UAHV,GAIC,2DALF,CADM,CAAP;AASA;;AACD,SAAO3B,CAAC,CAACa,IAAF,CAAO,UAASW,IAAT,EAAe;AAC5B,WAAOnC,QAAQ,CAAC0C,UAAT,CAAoB;AAAEjC,MAAAA,GAAG,EAAE0B,IAAI,CAACL;AAAZ,KAApB,EAA0CN,IAA1C,CAA+C,UAASmB,KAAT,EAAgB;AACrER,MAAAA,IAAI,CAACH,OAAL,CAAaY,GAAb,GAAmBD,KAAnB,CADqE,CAC3C;;AAC1BR,MAAAA,IAAI,CAACL,MAAL,CAAYc,GAAZ,GAAkBD,KAAlB;AACA,aAAOR,IAAP;AACA,KAJM,CAAP;AAKA,GANM,CAAP;AAOA,CA/BD;;AAiCAnC,QAAQ,CAACyB,MAAT,GAAkB,UAASlB,IAAT,EAAe;AAChC,SAAOH,MAAM,CAACqB,MAAP,CAAclB,IAAd,EACLS,KADK,CACC,YAAW;AACjB,WAAOb,KAAK,CAACsB,MAAN,CAAalB,IAAb,CAAP;AACA,GAHK,EAILiB,IAJK,CAIA,UAASf,GAAT,EAAc;AACnB,WAAOT,QAAQ,CAAC0C,UAAT,CAAoB;AAAEjC,MAAAA,GAAG,EAAEA;AAAP,KAApB,EAAkCe,IAAlC,CAAuC,UAASmB,KAAT,EAAgB;AAC7DlC,MAAAA,GAAG,CAACmC,GAAJ,GAAUD,KAAV;AACA,aAAOlC,GAAP;AACA,KAHM,CAAP;AAIA,GATK,CAAP;AAUA,CAXD;;AAaAT,QAAQ,CAACe,MAAT,GAAkB,UAASR,IAAT,EAAe;AAChC,SAAOH,MAAM,CAACW,MAAP,CAAcR,IAAd,EAAoBS,KAApB,CAA0B,UAASR,GAAT,EAAc;AAC9C,WAAOL,KAAK,CAACY,MAAN,CAAaR,IAAb,EAAmBS,KAAnB,CAAyB,YAAW;AAC1C,aAAOM,OAAO,CAACC,MAAR,CAAef,GAAf,CAAP;AACA,KAFM,CAAP;AAGA,GAJM,CAAP;AAKA,CAND,C,CAOA;;;AACAH,MAAM,CAACU,MAAP,GAAgBf,QAAQ,CAACe,MAAzB;AAEA;;;;;AAIAf,QAAQ,CAAC6C,MAAT,GAAkB,UAAStC,IAAT,EAAe;AAChC;AACA,MAAIE,GAAG,GAAG,EAAV;AACAqC,EAAAA,MAAM,CAACC,IAAP,CAAYxC,IAAI,CAACE,GAAjB,EAAsBuC,OAAtB,CAA8B,UAASC,CAAT,EAAY;AACzC,QAAI,gBAAgB,OAAO1C,IAAI,CAACE,GAAL,CAASwC,CAAT,CAA3B,EAAwC;AACvC;AACA,KAHwC,CAIzC;;;AACA,QAAI,CAAC,CAAD,KAAO,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,IAAhB,EAAsB,IAAtB,EAA4B,IAA5B,EAAkCC,OAAlC,CAA0CD,CAA1C,CAAX,EAAyD;AACxD;AACA;;AACDxC,IAAAA,GAAG,CAACwC,CAAD,CAAH,GAASnC,IAAI,CAACR,KAAL,CAAWQ,IAAI,CAACK,SAAL,CAAeZ,IAAI,CAACE,GAAL,CAASwC,CAAT,CAAf,CAAX,CAAT;AACA,GATD;AAUA,SAAOxC,GAAP;AACA,CAdD;;AAgBAT,QAAQ,CAAC0C,UAAT,GAAsB,UAASnC,IAAT,EAAe;AACpC,SAAOe,OAAO,CAACI,OAAR,GAAkBF,IAAlB,CAAuB,YAAW;AACxC,QAAI,MAAMgB,IAAN,CAAWjC,IAAI,CAACE,GAAL,CAASI,GAApB,CAAJ,EAA8B;AAC7B,aAAOT,MAAM,CAACsC,UAAP,CAAkBnC,IAAlB,CAAP;AACA,KAFD,MAEO;AACN,aAAOJ,KAAK,CAACuC,UAAN,CAAiBnC,IAAjB,CAAP;AACA;AACD,GANM,CAAP;AAOA,CARD;;AAUAP,QAAQ,CAAC4B,OAAT,GAAmB,UAASrB,IAAT,EAAe;AACjC,MAAI,aAAa,OAAOA,IAAI,CAACE,GAAzB,IAAgC,CAACF,IAAI,CAACE,GAAL,CAASI,GAA9C,EAAmD;AAClD,UAAM,IAAIK,KAAJ,CAAU,kBAAkBJ,IAAI,CAACK,SAAL,CAAeZ,IAAI,CAACE,GAApB,CAA5B,CAAN;AACA;AAED;;;AACA,MAAIA,GAAG,GAAGT,QAAQ,CAAC6C,MAAT,CAAgBtC,IAAhB,CAAV;;AAEA,MAAIE,GAAG,CAAC0C,GAAR,EAAa;AACZ1C,IAAAA,GAAG,CAAC0C,GAAJ,GAAUC,OAAO,CAAC3C,GAAG,CAAC0C,GAAL,CAAjB;AACA,GAFD,MAEO;AACN,QAAI5C,IAAI,CAAC4C,GAAT,EAAc;AACb1C,MAAAA,GAAG,CAAC0C,GAAJ,GAAUC,OAAO,CAAC7C,IAAI,CAAC4C,GAAN,CAAjB;AACA,KAFD,MAEO,IAAI5C,IAAI,CAAC8C,SAAT,EAAoB;AAC1B5C,MAAAA,GAAG,CAAC0C,GAAJ,GAAUG,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAgClD,IAAI,CAAC8C,SAA/C;AACA,KAFM,MAEA,IAAI9C,IAAI,CAACmD,SAAT,EAAoB;AAC1BjD,MAAAA,GAAG,CAAC0C,GAAJ,GAAU5C,IAAI,CAACmD,SAAf;AACA;AACD;;AACD,MAAI,CAACjD,GAAG,CAACkD,GAAL,IAAY,UAAUlD,GAAG,CAACkD,GAA9B,EAAmC;AAClClD,IAAAA,GAAG,CAACkD,GAAJ,GAAU,KAAV;AACA;;AAED,MAAIlD,GAAG,CAACmC,GAAR,EAAa;AACZ,WAAOtB,OAAO,CAACI,OAAR,CAAgBjB,GAAhB,CAAP;AACA;;AACD,SAAOT,QAAQ,CAAC0C,UAAT,CAAoB;AAAEjC,IAAAA,GAAG,EAAEA;AAAP,GAApB,EAAkCe,IAAlC,CAAuC,UAASmB,KAAT,EAAgB;AAC7DlC,IAAAA,GAAG,CAACmC,GAAJ,GAAUD,KAAV;AACA,WAAOlC,GAAP;AACA,GAHM,CAAP;AAIA,CA9BD,C,CAgCA;;;AACAT,QAAQ,CAAC4D,OAAT,GAAmB,UAASrD,IAAT,EAAe;AACjC,SAAOP,QAAQ,CAAC0C,UAAT,CAAoB;AAAEjC,IAAAA,GAAG,EAAEF,IAAI,CAACE;AAAZ,GAApB,EAAuCe,IAAvC,CAA4C,UAASmB,KAAT,EAAgB;AAClE,QAAIkB,MAAM,GAAGtD,IAAI,CAACsD,MAAL,IAAe,EAA5B;AACA,QAAIC,MAAM,GAAGhD,IAAI,CAACR,KAAL,CAAWQ,IAAI,CAACK,SAAL,CAAeZ,IAAI,CAACuD,MAAL,IAAe,EAA9B,CAAX,CAAb;AACAD,IAAAA,MAAM,CAACE,GAAP,GAAa,KAAb;;AAEA,QAAI,CAACF,MAAM,CAACjB,GAAR,IAAe,UAAUiB,MAAM,CAACjB,GAApC,EAAyC;AACxCiB,MAAAA,MAAM,CAACjB,GAAP,GAAaD,KAAb;AACA;;AACD,QAAI,CAACkB,MAAM,CAACG,GAAR,IAAezD,IAAI,CAACyD,GAAxB,EAA6B;AAC5BH,MAAAA,MAAM,CAACG,GAAP,GAAazD,IAAI,CAACyD,GAAlB;AACA;;AACD,QAAI,CAACF,MAAM,CAACG,GAAR,KAAgB,UAAUH,MAAM,CAACG,GAAjB,IAAwB,UAAU1D,IAAI,CAAC0D,GAAvD,CAAJ,EAAiE;AAChEH,MAAAA,MAAM,CAACG,GAAP,GAAaC,SAAb;AACA,KAFD,MAEO,IAAI,CAACJ,MAAM,CAACG,GAAZ,EAAiB;AACvBH,MAAAA,MAAM,CAACG,GAAP,GAAaX,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAb;AACA;;AAED,QAAIlD,IAAI,CAAC4C,GAAT,EAAc;AACbW,MAAAA,MAAM,CAACX,GAAP,GAAaC,OAAO,CAAC7C,IAAI,CAAC4C,GAAN,CAApB;AACA,KAFD,MAEO,IACN,CAACW,MAAM,CAACX,GAAR,KACC,UAAUW,MAAM,CAACX,GAAjB,IAAwB,UAAU5C,IAAI,CAAC4C,GADxC,CADM,EAGL;AACDW,MAAAA,MAAM,CAACX,GAAP,GAAae,SAAb;AACA,KALM,MAKA,IAAI,CAACJ,MAAM,CAACX,GAAZ,EAAiB;AACvB,YAAM,IAAIjC,KAAJ,CACL,oGADK,CAAN;AAGA;;AAED,QAAIX,IAAI,CAAC4D,GAAT,EAAc;AACbL,MAAAA,MAAM,CAACK,GAAP,GAAa5D,IAAI,CAAC4D,GAAlB;AACA;;AACD,QAAI,CAACL,MAAM,CAACK,GAAR,KAAgB,UAAUL,MAAM,CAACK,GAAjB,IAAwB,UAAU5D,IAAI,CAAC4D,GAAvD,CAAJ,EAAiE;AAChEL,MAAAA,MAAM,CAACK,GAAP,GAAaD,SAAb;AACA,KAFD,MAEO,IAAI,CAACJ,MAAM,CAACK,GAAZ,EAAiB;AACvB,YAAM,IAAIjD,KAAJ,CACL,uFADK,CAAN;AAGA;;AAED,WAAOlB,QAAQ,CAACoE,OAAT,CAAiB;AACvB3D,MAAAA,GAAG,EAAEF,IAAI,CAACE,GADa;AAEvBC,MAAAA,GAAG,EAAEH,IAAI,CAACG,GAFa;AAGvB2D,MAAAA,SAAS,EAAER,MAHY;AAIvBA,MAAAA,MAAM,EAAEK,SAJe;AAKvBI,MAAAA,OAAO,EAAER;AALc,KAAjB,EAMJtC,IANI,CAMC,UAAS+C,GAAT,EAAc;AACrB,aAAO,CAACA,GAAG,CAACF,SAAL,EAAgBE,GAAG,CAACD,OAApB,EAA6BC,GAAG,CAACC,SAAjC,EAA4CC,IAA5C,CAAiD,GAAjD,CAAP;AACA,KARM,CAAP;AASA,GAlDM,CAAP;AAmDA,CApDD;;AAsDAzE,QAAQ,CAACoE,OAAT,GAAmB,UAAS7D,IAAT,EAAe;AACjC,SAAOP,QAAQ,CAAC0C,UAAT,CAAoBnC,IAApB,EAA0BiB,IAA1B,CAA+B,UAASmB,KAAT,EAAgB;AACrD,aAASqB,GAAT,GAAe;AACd,UAAI,CAACzD,IAAI,CAACE,GAAV,EAAe;AACd,cAAM,IAAIS,KAAJ,CAAU,4CAAV,CAAN;AACA;;AACD,UAAIX,IAAI,CAACE,GAAL,CAASuD,GAAb,EAAkB;AACjB,eAAOzD,IAAI,CAACE,GAAL,CAASuD,GAAhB;AACA;;AACD,UAAID,GAAG,GAAG,UAAUxD,IAAI,CAACE,GAAL,CAASI,GAAnB,GAAyB,IAAzB,GAAgC,IAA1C;AACA,aAAOkD,GAAG,GAAG/D,QAAQ,CAAC0E,QAAT,CAAkBnE,IAAlB,CAAb;AACA;;AAED,aAASoE,IAAT,GAAgB;AACf,UAAIC,OAAO,GAAGrE,IAAI,CAAC8D,SAAnB;AACA,UAAIC,OAAO,GAAG/D,IAAI,CAAC+D,OAAnB,CAFe,CAIf;;AACA,UAAIO,eAAe,GAAG,EAAtB,CALe,CAMf;AACA;;AACA,UAAI,UAAUD,OAAd,EAAuB;AACtB,YAAI,CAACA,OAAL,EAAc;AACbA,UAAAA,OAAO,GAAG,EAAV;AACA;;AACD,YAAI,CAACA,OAAO,CAACZ,GAAb,EAAkB;AACjBY,UAAAA,OAAO,CAACZ,GAAR,GAAcA,GAAG,EAAjB;AACA,SANqB,CAOtB;;;AACA,YAAI,UAAUY,OAAO,CAAChC,GAAtB,EAA2B;AAC1BgC,UAAAA,OAAO,CAAChC,GAAR,GAAcsB,SAAd;AACA,SAFD,MAEO,IAAI,CAACU,OAAO,CAAChC,GAAb,EAAkB;AACxBgC,UAAAA,OAAO,CAAChC,GAAR,GAAcD,KAAd;AACA;;AACDkC,QAAAA,eAAe,GAAG/D,IAAI,CAACK,SAAL,CAAeyD,OAAf,CAAlB;AACA,OAtBc,CAwBf;AACA;AACA;AACA;AACA;;;AACA,UACCN,OAAO,IACP,aAAa,OAAOA,OADpB,IAEA,gBAAgB,OAAOA,OAAO,CAACQ,UAF/B,IAGA,gBAAgB,OAAOR,OAAO,CAACS,MAJhC,EAKE;AACDT,QAAAA,OAAO,GAAGxD,IAAI,CAACK,SAAL,CAAemD,OAAf,CAAV;AACA,OApCc,CAqCf;;;AACA,UAAI,aAAa,OAAOA,OAAxB,EAAiC;AAChCA,QAAAA,OAAO,GAAGvE,GAAG,CAACiF,QAAJ,CAAaV,OAAb,CAAV;AACA;;AAED,UAAIW,WAAW,GAAGlF,GAAG,CAACmF,cAAJ,CAAmBL,eAAnB,CAAlB;AACA,UAAIM,SAAS,GAAGpF,GAAG,CAACqF,cAAJ,CAAmBd,OAAnB,CAAhB;AACA,UAAIe,GAAG,GAAGJ,WAAW,GAAG,GAAd,GAAoBE,SAA9B;AAEA,aAAO9E,MAAM,CAACiF,KAAP,CAAa/E,IAAb,EAAmB8E,GAAnB,EAAwB7D,IAAxB,CAA6B,UAAS+D,GAAT,EAAc;AACjD,YAAIC,SAAS,GAAG;AACfnB,UAAAA,SAAS,EAAEY,WADI;AAEfX,UAAAA,OAAO,EAAEa,SAFM;AAGfX,UAAAA,SAAS,EAAEzE,GAAG,CAACqF,cAAJ,CAAmBG,GAAnB;AAHI,SAAhB;AAMA,eAAOC,SAAP;AACA,OARM,CAAP;AASA;;AAED,QAAIjF,IAAI,CAACE,GAAT,EAAc;AACb,aAAOkE,IAAI,EAAX;AACA,KAFD,MAEO;AACN,aAAO3E,QAAQ,CAACyB,MAAT,CAAgB;AAAEf,QAAAA,GAAG,EAAEH,IAAI,CAACG;AAAZ,OAAhB,EAAmCc,IAAnC,CAAwC,UAASW,IAAT,EAAe;AAC7D5B,QAAAA,IAAI,CAACE,GAAL,GAAW0B,IAAI,CAACH,OAAhB;AACA,eAAO2C,IAAI,EAAX;AACA,OAHM,CAAP;AAIA;AACD,GA7EM,CAAP;AA8EA,CA/ED,C,CAiFA;;;AACA3E,QAAQ,CAAC2E,IAAT,GAAgBtE,MAAM,CAACiF,KAAvB;;AAEAtF,QAAQ,CAAC0E,QAAT,GAAoB,UAASnE,IAAT,EAAe;AAClC,MAAIA,IAAI,CAACyD,GAAT,EAAc;AACb,WAAOzD,IAAI,CAACyD,GAAL,CAASyB,OAAT,CAAiB,WAAjB,EAA8B,EAA9B,CAAP;AACA;;AACD,MAAIlF,IAAI,CAAC8D,SAAL,IAAkB9D,IAAI,CAAC8D,SAAL,CAAeL,GAArC,EAA0C;AACzC,WAAOzD,IAAI,CAAC8D,SAAL,CAAeL,GAAf,CAAmByB,OAAnB,CAA2B,WAA3B,EAAwC,EAAxC,CAAP;AACA,GANiC,CAOlC;;;AACA,MAAIC,GAAG,GAAGpC,IAAI,CAACqC,KAAL,CAAW,CAACpF,IAAI,CAACE,GAAL,CAASmF,CAAT,IAAc,EAAf,EAAmBC,MAAnB,GAA4B,IAAvC,CAAV,CARkC,CAUlC;AACA;;AACA,MAAI,MAAMrD,IAAN,CAAWjC,IAAI,CAACE,GAAL,CAASqF,GAApB,KAA4BJ,GAAG,IAAI,GAAvC,EAA4C;AAC3C,WAAO,KAAP;AACA,GAFD,MAEO,IAAI,MAAMlD,IAAN,CAAWjC,IAAI,CAACE,GAAL,CAASqF,GAApB,KAA4BJ,GAAG,IAAI,GAAvC,EAA4C;AAClD,WAAO,KAAP;AACA;;AAED,SAAO,KAAP;AACA,CAnBD,C,CAoBA;;;AACArF,MAAM,CAACqE,QAAP,GAAkB1E,QAAQ,CAAC0E,QAA3B;;AAEA,SAAStB,OAAT,CAAiB2C,IAAjB,EAAuB;AACtB,MAAI,aAAa,OAAOA,IAAxB,EAA8B;AAC7B,WAAOA,IAAP;AACA;;AAED,MAAIC,CAAC,GAAGD,IAAI,CAACE,KAAL,CAAW,qBAAX,CAAR;;AACA,MAAI,CAACD,CAAD,IAAM,CAACA,CAAC,CAAC,CAAD,CAAZ,EAAiB;AAChB,UAAM,IAAI9E,KAAJ,CACL,MACC6E,IADD,GAEC,iFAHI,CAAN;AAKA;;AAED,MAAItC,GAAG,GAAGH,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAV;AACA,MAAIyC,GAAG,GAAGC,QAAQ,CAACH,CAAC,CAAC,CAAD,CAAF,EAAO,EAAP,CAAlB;AACA,MAAII,IAAI,GAAGJ,CAAC,CAAC,CAAD,CAAZ;AACA,MAAIK,IAAI,GAAG,CAAX;;AACA,UAAQD,IAAR;AACC;AACA,SAAK,GAAL;AACCC,MAAAA,IAAI,IAAI,EAAR;;AACD;;AACA,SAAK,GAAL;AACCA,MAAAA,IAAI,IAAI,EAAR;;AACD;;AACA,SAAK,GAAL;AACCA,MAAAA,IAAI,IAAI,EAAR;;AACD;;AACA,SAAK,GAAL;AACCA,MAAAA,IAAI,IAAI,CAAR;AAZF;;AAeA,SAAO5C,GAAG,GAAG4C,IAAI,GAAGH,GAApB;AACA","sourcesContent":["/*global Promise*/\n'use strict';\n\nrequire('@root/encoding/bytes');\nvar Enc = require('@root/encoding/base64');\n\nvar Keypairs = module.exports;\nvar Rasha = require('./rsa.js');\nvar Eckles = require('./ecdsa.js');\nvar native = require('./lib/node/keypairs.js');\n\nKeypairs.parse = function(opts) {\n\topts = opts || {};\n\n\tvar err;\n\tvar jwk;\n\tvar pem;\n\tvar p;\n\n\tif (!opts.key || !opts.key.kty) {\n\t\ttry {\n\t\t\tjwk = JSON.parse(opts.key);\n\t\t\tp = Keypairs.export({ jwk: jwk })\n\t\t\t\t.catch(function(e) {\n\t\t\t\t\tpem = opts.key;\n\t\t\t\t\terr = new Error(\n\t\t\t\t\t\t\"Not a valid jwk '\" +\n\t\t\t\t\t\t\tJSON.stringify(jwk) +\n\t\t\t\t\t\t\t\"':\" +\n\t\t\t\t\t\t\te.message\n\t\t\t\t\t);\n\t\t\t\t\terr.code = 'EINVALID';\n\t\t\t\t\treturn Promise.reject(err);\n\t\t\t\t})\n\t\t\t\t.then(function() {\n\t\t\t\t\treturn jwk;\n\t\t\t\t});\n\t\t} catch (e) {\n\t\t\tp = Keypairs.import({ pem: opts.key }).catch(function(e) {\n\t\t\t\terr = new Error(\n\t\t\t\t\t'Could not parse key (type ' +\n\t\t\t\t\t\ttypeof opts.key +\n\t\t\t\t\t\t\") '\" +\n\t\t\t\t\t\topts.key +\n\t\t\t\t\t\t\"': \" +\n\t\t\t\t\t\te.message\n\t\t\t\t);\n\t\t\t\terr.code = 'EPARSE';\n\t\t\t\treturn Promise.reject(err);\n\t\t\t});\n\t\t}\n\t} else {\n\t\tp = Promise.resolve(opts.key);\n\t}\n\n\treturn p.then(function(jwk) {\n\t\tvar pubopts = JSON.parse(JSON.stringify(opts));\n\t\tpubopts.jwk = jwk;\n\t\treturn Keypairs.publish(pubopts).then(function(pub) {\n\t\t\t// 'd' happens to be the name of a private part of both RSA and ECDSA keys\n\t\t\tif (opts.public || opts.publish || !jwk.d) {\n\t\t\t\tif (opts.private) {\n\t\t\t\t\t// TODO test that it can actually sign?\n\t\t\t\t\terr = new Error(\n\t\t\t\t\t\t\"Not a private key '\" + JSON.stringify(jwk) + \"'\"\n\t\t\t\t\t);\n\t\t\t\t\terr.code = 'ENOTPRIVATE';\n\t\t\t\t\treturn Promise.reject(err);\n\t\t\t\t}\n\t\t\t\treturn { public: pub };\n\t\t\t} else {\n\t\t\t\treturn { private: jwk, public: pub };\n\t\t\t}\n\t\t});\n\t});\n};\n\nKeypairs.parseOrGenerate = function(opts) {\n\tif (!opts.key) {\n\t\treturn Keypairs.generate(opts);\n\t}\n\topts.private = true;\n\treturn Keypairs.parse(opts).catch(function(e) {\n\t\treturn Keypairs.generate(opts).then(function(pair) {\n\t\t\tpair.parseError = e;\n\t\t\treturn pair;\n\t\t});\n\t});\n};\n\nKeypairs._stance =\n\t\"We take the stance that if you're knowledgeable enough to\" +\n\t\" properly and securely use non-standard crypto then you shouldn't need Bluecrypt anyway.\";\nKeypairs._universal =\n\t'Bluecrypt only supports crypto with standard cross-browser and cross-platform support.';\nKeypairs.generate = function(opts) {\n\topts = opts || {};\n\tvar p;\n\tif (!opts.kty) {\n\t\topts.kty = opts.type;\n\t}\n\tif (!opts.kty) {\n\t\topts.kty = 'EC';\n\t}\n\tif (/^EC/i.test(opts.kty)) {\n\t\tp = Eckles.generate(opts);\n\t} else if (/^RSA$/i.test(opts.kty)) {\n\t\tp = Rasha.generate(opts);\n\t} else {\n\t\treturn Promise.Reject(\n\t\t\tnew Error(\n\t\t\t\t\"'\" +\n\t\t\t\t\topts.kty +\n\t\t\t\t\t\"' is not a well-supported key type.\" +\n\t\t\t\t\tKeypairs._universal +\n\t\t\t\t\t\" Please choose 'EC', or 'RSA' if you have good reason to.\"\n\t\t\t)\n\t\t);\n\t}\n\treturn p.then(function(pair) {\n\t\treturn Keypairs.thumbprint({ jwk: pair.public }).then(function(thumb) {\n\t\t\tpair.private.kid = thumb; // maybe not the same id on the private key?\n\t\t\tpair.public.kid = thumb;\n\t\t\treturn pair;\n\t\t});\n\t});\n};\n\nKeypairs.import = function(opts) {\n\treturn Eckles.import(opts)\n\t\t.catch(function() {\n\t\t\treturn Rasha.import(opts);\n\t\t})\n\t\t.then(function(jwk) {\n\t\t\treturn Keypairs.thumbprint({ jwk: jwk }).then(function(thumb) {\n\t\t\t\tjwk.kid = thumb;\n\t\t\t\treturn jwk;\n\t\t\t});\n\t\t});\n};\n\nKeypairs.export = function(opts) {\n\treturn Eckles.export(opts).catch(function(err) {\n\t\treturn Rasha.export(opts).catch(function() {\n\t\t\treturn Promise.reject(err);\n\t\t});\n\t});\n};\n// XXX\nnative.export = Keypairs.export;\n\n/**\n * Chopping off the private parts is now part of the public API.\n * I thought it sounded a little too crude at first, but it really is the best name in every possible way.\n */\nKeypairs.neuter = function(opts) {\n\t/** trying to find the best balance of an immutable copy with custom attributes */\n\tvar jwk = {};\n\tObject.keys(opts.jwk).forEach(function(k) {\n\t\tif ('undefined' === typeof opts.jwk[k]) {\n\t\t\treturn;\n\t\t}\n\t\t// ignore RSA and EC private parts\n\t\tif (-1 !== ['d', 'p', 'q', 'dp', 'dq', 'qi'].indexOf(k)) {\n\t\t\treturn;\n\t\t}\n\t\tjwk[k] = JSON.parse(JSON.stringify(opts.jwk[k]));\n\t});\n\treturn jwk;\n};\n\nKeypairs.thumbprint = function(opts) {\n\treturn Promise.resolve().then(function() {\n\t\tif (/EC/i.test(opts.jwk.kty)) {\n\t\t\treturn Eckles.thumbprint(opts);\n\t\t} else {\n\t\t\treturn Rasha.thumbprint(opts);\n\t\t}\n\t});\n};\n\nKeypairs.publish = function(opts) {\n\tif ('object' !== typeof opts.jwk || !opts.jwk.kty) {\n\t\tthrow new Error('invalid jwk: ' + JSON.stringify(opts.jwk));\n\t}\n\n\t/** returns a copy */\n\tvar jwk = Keypairs.neuter(opts);\n\n\tif (jwk.exp) {\n\t\tjwk.exp = setTime(jwk.exp);\n\t} else {\n\t\tif (opts.exp) {\n\t\t\tjwk.exp = setTime(opts.exp);\n\t\t} else if (opts.expiresIn) {\n\t\t\tjwk.exp = Math.round(Date.now() / 1000) + opts.expiresIn;\n\t\t} else if (opts.expiresAt) {\n\t\t\tjwk.exp = opts.expiresAt;\n\t\t}\n\t}\n\tif (!jwk.use && false !== jwk.use) {\n\t\tjwk.use = 'sig';\n\t}\n\n\tif (jwk.kid) {\n\t\treturn Promise.resolve(jwk);\n\t}\n\treturn Keypairs.thumbprint({ jwk: jwk }).then(function(thumb) {\n\t\tjwk.kid = thumb;\n\t\treturn jwk;\n\t});\n};\n\n// JWT a.k.a. JWS with Claims using Compact Serialization\nKeypairs.signJwt = function(opts) {\n\treturn Keypairs.thumbprint({ jwk: opts.jwk }).then(function(thumb) {\n\t\tvar header = opts.header || {};\n\t\tvar claims = JSON.parse(JSON.stringify(opts.claims || {}));\n\t\theader.typ = 'JWT';\n\n\t\tif (!header.kid && false !== header.kid) {\n\t\t\theader.kid = thumb;\n\t\t}\n\t\tif (!header.alg && opts.alg) {\n\t\t\theader.alg = opts.alg;\n\t\t}\n\t\tif (!claims.iat && (false === claims.iat || false === opts.iat)) {\n\t\t\tclaims.iat = undefined;\n\t\t} else if (!claims.iat) {\n\t\t\tclaims.iat = Math.round(Date.now() / 1000);\n\t\t}\n\n\t\tif (opts.exp) {\n\t\t\tclaims.exp = setTime(opts.exp);\n\t\t} else if (\n\t\t\t!claims.exp &&\n\t\t\t(false === claims.exp || false === opts.exp)\n\t\t) {\n\t\t\tclaims.exp = undefined;\n\t\t} else if (!claims.exp) {\n\t\t\tthrow new Error(\n\t\t\t\t\"opts.claims.exp should be the expiration date as seconds, human form (i.e. '1h' or '15m') or false\"\n\t\t\t);\n\t\t}\n\n\t\tif (opts.iss) {\n\t\t\tclaims.iss = opts.iss;\n\t\t}\n\t\tif (!claims.iss && (false === claims.iss || false === opts.iss)) {\n\t\t\tclaims.iss = undefined;\n\t\t} else if (!claims.iss) {\n\t\t\tthrow new Error(\n\t\t\t\t'opts.claims.iss should be in the form of https://example.com/, a secure OIDC base url'\n\t\t\t);\n\t\t}\n\n\t\treturn Keypairs.signJws({\n\t\t\tjwk: opts.jwk,\n\t\t\tpem: opts.pem,\n\t\t\tprotected: header,\n\t\t\theader: undefined,\n\t\t\tpayload: claims\n\t\t}).then(function(jws) {\n\t\t\treturn [jws.protected, jws.payload, jws.signature].join('.');\n\t\t});\n\t});\n};\n\nKeypairs.signJws = function(opts) {\n\treturn Keypairs.thumbprint(opts).then(function(thumb) {\n\t\tfunction alg() {\n\t\t\tif (!opts.jwk) {\n\t\t\t\tthrow new Error(\"opts.jwk must exist and must declare 'typ'\");\n\t\t\t}\n\t\t\tif (opts.jwk.alg) {\n\t\t\t\treturn opts.jwk.alg;\n\t\t\t}\n\t\t\tvar typ = 'RSA' === opts.jwk.kty ? 'RS' : 'ES';\n\t\t\treturn typ + Keypairs._getBits(opts);\n\t\t}\n\n\t\tfunction sign() {\n\t\t\tvar protect = opts.protected;\n\t\t\tvar payload = opts.payload;\n\n\t\t\t// Compute JWS signature\n\t\t\tvar protectedHeader = '';\n\t\t\t// Because unprotected headers are allowed, regrettably...\n\t\t\t// https://stackoverflow.com/a/46288694\n\t\t\tif (false !== protect) {\n\t\t\t\tif (!protect) {\n\t\t\t\t\tprotect = {};\n\t\t\t\t}\n\t\t\t\tif (!protect.alg) {\n\t\t\t\t\tprotect.alg = alg();\n\t\t\t\t}\n\t\t\t\t// There's a particular request where ACME / Let's Encrypt explicitly doesn't use a kid\n\t\t\t\tif (false === protect.kid) {\n\t\t\t\t\tprotect.kid = undefined;\n\t\t\t\t} else if (!protect.kid) {\n\t\t\t\t\tprotect.kid = thumb;\n\t\t\t\t}\n\t\t\t\tprotectedHeader = JSON.stringify(protect);\n\t\t\t}\n\n\t\t\t// Not sure how to handle the empty case since ACME POST-as-GET must be empty\n\t\t\t//if (!payload) {\n\t\t\t//  throw new Error(\"opts.payload should be JSON, string, or ArrayBuffer (it may be empty, but that must be explicit)\");\n\t\t\t//}\n\t\t\t// Trying to detect if it's a plain object (not Buffer, ArrayBuffer, Array, Uint8Array, etc)\n\t\t\tif (\n\t\t\t\tpayload &&\n\t\t\t\t'string' !== typeof payload &&\n\t\t\t\t'undefined' === typeof payload.byteLength &&\n\t\t\t\t'undefined' === typeof payload.buffer\n\t\t\t) {\n\t\t\t\tpayload = JSON.stringify(payload);\n\t\t\t}\n\t\t\t// Converting to a buffer, even if it was just converted to a string\n\t\t\tif ('string' === typeof payload) {\n\t\t\t\tpayload = Enc.strToBuf(payload);\n\t\t\t}\n\n\t\t\tvar protected64 = Enc.strToUrlBase64(protectedHeader);\n\t\t\tvar payload64 = Enc.bufToUrlBase64(payload);\n\t\t\tvar msg = protected64 + '.' + payload64;\n\n\t\t\treturn native._sign(opts, msg).then(function(buf) {\n\t\t\t\tvar signedMsg = {\n\t\t\t\t\tprotected: protected64,\n\t\t\t\t\tpayload: payload64,\n\t\t\t\t\tsignature: Enc.bufToUrlBase64(buf)\n\t\t\t\t};\n\n\t\t\t\treturn signedMsg;\n\t\t\t});\n\t\t}\n\n\t\tif (opts.jwk) {\n\t\t\treturn sign();\n\t\t} else {\n\t\t\treturn Keypairs.import({ pem: opts.pem }).then(function(pair) {\n\t\t\t\topts.jwk = pair.private;\n\t\t\t\treturn sign();\n\t\t\t});\n\t\t}\n\t});\n};\n\n// TODO expose consistently\nKeypairs.sign = native._sign;\n\nKeypairs._getBits = function(opts) {\n\tif (opts.alg) {\n\t\treturn opts.alg.replace(/[a-z\\-]/gi, '');\n\t}\n\tif (opts.protected && opts.protected.alg) {\n\t\treturn opts.protected.alg.replace(/[a-z\\-]/gi, '');\n\t}\n\t// base64 len to byte len\n\tvar len = Math.floor((opts.jwk.n || '').length * 0.75);\n\n\t// TODO this may be a bug\n\t// need to confirm that the padding is no more or less than 1 byte\n\tif (/521/.test(opts.jwk.crv) || len >= 511) {\n\t\treturn '512';\n\t} else if (/384/.test(opts.jwk.crv) || len >= 383) {\n\t\treturn '384';\n\t}\n\n\treturn '256';\n};\n// XXX\nnative._getBits = Keypairs._getBits;\n\nfunction setTime(time) {\n\tif ('number' === typeof time) {\n\t\treturn time;\n\t}\n\n\tvar t = time.match(/^(\\-?\\d+)([dhms])$/i);\n\tif (!t || !t[0]) {\n\t\tthrow new Error(\n\t\t\t\"'\" +\n\t\t\t\ttime +\n\t\t\t\t\"' should be datetime in seconds or human-readable format (i.e. 3d, 1h, 15m, 30s\"\n\t\t);\n\t}\n\n\tvar now = Math.round(Date.now() / 1000);\n\tvar num = parseInt(t[1], 10);\n\tvar unit = t[2];\n\tvar mult = 1;\n\tswitch (unit) {\n\t\t// fancy fallthrough, what fun!\n\t\tcase 'd':\n\t\t\tmult *= 24;\n\t\t/*falls through*/\n\t\tcase 'h':\n\t\t\tmult *= 60;\n\t\t/*falls through*/\n\t\tcase 'm':\n\t\t\tmult *= 60;\n\t\t/*falls through*/\n\t\tcase 's':\n\t\t\tmult *= 1;\n\t}\n\n\treturn now + mult * num;\n}\n"]},"metadata":{},"sourceType":"script"}